---
title: "morefigs"
author: "JJ"
date: "2025-08-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
Sys.setenv(RETICULATE_PYTHON="~/.virtualenvs/r-reticulate-x86_64/bin/python")

library(tidyverse)
library(ggplot2)
library(dplyr)
# library(arrow)
library(gridExtra)
library(rlang)
library(patchwork)
library(synapser)
library(ggridges)
library(RColorBrewer)
library(reticulate)
library(tidyr)
library(plotly)

suppressWarnings(suppressMessages({
  if (!requireNamespace("ggrepel", quietly = TRUE)) install.packages("ggrepel")
  if (!requireNamespace("patchwork", quietly = TRUE)) install.packages("patchwork")
}))
```


# Setup the Data
```{r setup, include=FALSE}

models <- c('deepttc','graphdrp','lgbm','xgboostdrp','uno')
modelcolors <- RColorBrewer::brewer.pal(n=6,name='RdYlBu')
names(modelcolors) <- models


exvivo = c('mpnst','beataml','sarcoma','pancreatic','bladder','liver','novartis','colorectal')
cellline = c('nci60','ctrpv2','fimm','gcsi','gdscv1','gdscv2','prism','ccle')

ccols = RColorBrewer::brewer.pal(n = length(cellline),name = 'RdBu')
names(ccols) <- cellline

ecols = RColorBrewer::brewer.pal(n = length(exvivo),name = 'PRGn')
names(ecols) <- exvivo

datasetcolors <- c(ccols,ecols)

synapser::synLogin()

getProteomicsData <- function(){

  allscoreslist <- list(lgbm = 'syn68156330')
  fullres <- do.call(rbind,lapply(names(allscoreslist),function(mod)
    readr::read_csv(synapser::synGet(allscoreslist[[mod]])$path) |> mutate(model = mod)))

  fullres <- fullres |>
    mutate(withinDataset = ifelse(src == trg,TRUE,FALSE))

  #lets remove same-dataset data. - I'm going to keep it actually...
 # cdres <- subset(fullres,!withinDataset)

  ##lets remove ex vivo training
  fullres <- subset(fullres,!src %in% c('mpnst','beataml'))

  return(fullres)

}

getModelPerformanceData <- function(include_within = TRUE){
  allscoreslist <- list(deepttc='syn69960485', graphdrp='syn69953705',
                        lgbm='syn69931939', xgboostdrp='syn69931970', uno='syn69953101')

  fullres <- purrr::imap_dfr(allscoreslist, \(id, mod)
    readr::read_csv(synapser::synGet(id)$path, show_col_types = FALSE) |> mutate(model = mod))

  fullres <- fullres |>
    mutate(withinDataset = src == trg)

  cdres <- if (include_within) fullres else subset(fullres, !withinDataset)

  cdres <- subset(cdres, !src %in% c('mpnst','beataml'))
  cdres
}

# Replaced arrow with reticulate/pandas - feel free to swap back.
# this currently only retrieves one dataset at a time and returns an appache
# "arrow" tabular dataset object that can be interacted / queried via dplyr
# getModelPredictionData <- function(dset='lgbm') {
# 
#   preds <- list(
#     deepttc = "syn69960497",
#     graphdrp = "syn69953716",
#     lgbm = "syn69931953",
#     xgboostdrp = "syn69931981",
#     uno = "syn69953114"
#   )
# 
#   dataset <- arrow::open_dataset(
#     sources = synapser::synGet(preds[[dset]])$path,
#     format = "parquet"
#     )
# 
#   return(dataset)
# }

getModelPredictionData <- function(dset = "lgbm") {
  preds <- list(
    deepttc="syn69960497", graphdrp="syn69953716", lgbm="syn69931953",
    xgboostdrp="syn69931981", uno="syn69953114"
  )
  p <- synapser::synGet(preds[[dset]])$path
  if (dir.exists(p)) p <- file.path(p, "*.parquet")

  pd <- import("pandas", convert = FALSE)
  df_py <- pd$read_parquet(p)
  as_tibble(reticulate::py_to_r(df_py))
}

ridgelineMetricPlots <- function(metric,dataset=cdres, prefix='all'){

    sr <- dataset |>
    subset(met == metric)

  mvals <- sr |> group_by(src) |>
    summarize(mvals = mean(value)) |>
    arrange(mvals)

  if (metric == 'r2') {
    sr$value <- sapply(sr$value,function(x) ifelse(x < (-1),-1,x))
  }

  sr$src = factor(sr$src,levels = mvals$src)

  #compare models by source dataset
  p1 <- sr |>
    ggplot(aes(x = value,y = trg,fill = model)) +
    ggridges::geom_density_ridges(alpha = 0.5) +
    facet_grid(src~.) +
    ggtitle(paste0(metric,' by source dataset'))+
    scale_fill_manual(values=modelcolors)

  ##now we rerank by target dataset and evaluate by target
  mvals <- sr |> group_by(trg) |>
    summarize(mvals = mean(value)) |>
    arrange(mvals)
  sr$trg = factor(sr$trg,levels = mvals$trg)

  #plot source by target data
  p3 <- sr |>
    ggplot(aes(x = value,y = src,fill = model)) +
    ggridges::geom_density_ridges(alpha = 0.5) +
    facet_grid(trg~.) +
    ggtitle(paste0(metric,' by target dataset'))+
    scale_fill_manual(values=modelcolors)


  return(list(src=p1,trg=p3))
}


##here we have to interrogate the results to visualize how specific drugs are behaving
performanceByDrugOrSample <- function(){

}

## calculate source dataset statistics
## how do features of the source dataset impact  performance?
calcSourceStatistics<-function(metric, dataset=cdres){
  #number of combos
  combos = c(ccle = 10911,ctrpv2 = 303520,fimm = 2457 ,gcsi = 12320,
             gdscv1 = 105808,gdscv2 = 45323, nci60 = 2317205,prism = 633169)

  numsamples = c(ccle = 503, ctrpv2 = 847, fimm=52, gcsi = 571, gdscv1 = 984,
                 gdscv2 = 806, nci60 = 83, prism = 478)
  numdrugs = c(ccle = 24, ctrpv2 = 461, fimm=52, gcsi = 43, gdscv1 = 296, gdscv2 = 169,
               nci60 = 54707, prism = 1418)

  stats = data.frame(Samples = numsamples, Drugs =numdrugs, Combos = combos)
  stats$src = rownames(stats)

  #todo: we can also evaluate number of samples or drugs

  #e can get performance summaries
  gres <- dataset  |>
    #subset(model!='uno')|>
    subset(met==metric) |>
    group_by(met,src,trg,model) |>
    summarize(meanVal=mean(value,na.rm=TRUE)) |>
    left_join(stats) |>
    arrange(meanVal)

  p1 <- ggplot(gres, aes(x=Samples, y = meanVal,col=model))+
    geom_point()+scale_x_log10()+scale_color_manual(values=modelcolors)+geom_smooth(method=lm, alpha=0.2)+theme_bw()

  p2 <- ggplot(gres, aes(x=Drugs, y = meanVal,col=model))+
    geom_point()+scale_x_log10()+scale_color_manual(values=modelcolors)+geom_smooth(method=lm, alpha=0.2)+theme_bw()

  p3 <- ggplot(gres, aes(x=Combos, y = meanVal,col=model))+
    geom_point()+scale_x_log10()+scale_color_manual(values=modelcolors)+geom_smooth(method=lm, alpha=0.2)+theme_bw()

  corvals <- gres |>
    ungroup() |>
    group_by(model) |>
    summarize(Sample=cor(Samples,meanVal),Drugs=cor(Drugs,meanVal),Combinations=cor(Combos,meanVal,use='pairwise.complete.obs'))|>
    tidyr::pivot_longer(cols=c(2,3,4),names_to='statistic',values_to='correlation')

  p4 <- ggplot(corvals, aes(x=statistic,y=correlation,fill=model)) + geom_bar(position='dodge',stat='identity') +
    scale_fill_manual(values=modelcolors) + theme_bw()

  return(cowplot::plot_grid(p1,p2,p3,p4,nrow=4))
}

##do we still need this function?

# Display + save plots for a given metric
doModelPlot <- function(metric, dataset = cdres, outdir = ".", save_files = TRUE) {

  sr <- subset(dataset, met == metric)

  # Clamp only for r2 (to keep histograms sane)
  if (identical(metric, "r2")) {
    sr$value <- ifelse(sr$value < -1, -1, sr$value)
  }

  # Re-rank by target mean to order facets
  mvals <- sr |>
    dplyr::group_by(trg) |>
    dplyr::summarize(mvals = mean(value, na.rm = TRUE), .groups = "drop") |>
    dplyr::arrange(mvals)
  sr$trg <- factor(sr$trg, levels = mvals$trg)

  # ---- ex vivo panel
  p_ex <- sr |>
    subset(trg %in% exvivo) |>
    ggplot2::ggplot(ggplot2::aes(x = value, alpha = 0.8)) +
    ggplot2::geom_histogram(bins = 30) +
    ggplot2::facet_grid(model ~ trg) +
    ggplot2::ggtitle(paste0(metric, " evaluated on ex vivo data"))

  # Print so it shows in R (Rscript, RStudio, knitr, etc.)
  print(p_ex)

  if (isTRUE(save_files)) {
    ggplot2::ggsave(
      filename = file.path(outdir, paste0(metric, "_exVivoPerformance.png")),
      plot = p_ex, width = 10, height = 8, dpi = 300
    )
  }

  # ---- cell-line panel
  p_cl <- sr |>
    subset(!trg %in% exvivo) |>
    ggplot2::ggplot(ggplot2::aes(x = value, alpha = 0.8)) +
    ggplot2::geom_histogram(bins = 30) +
    ggplot2::facet_grid(model ~ trg) +
    ggplot2::ggtitle(paste0(metric, " evaluated on cell line data"))

  print(p_cl)

  if (isTRUE(save_files)) {
    ggplot2::ggsave(
      filename = file.path(outdir, paste0(metric, "_CellLinePerformance.png")),
      plot = p_cl, width = 10, height = 8, dpi = 300
    )
  }

  invisible(list(exvivo = p_ex, cellline = p_cl))
}


doModelPlot(metric = 'r2')

```


```{r}
# this is originally from "coderdataResultsFunctions.R
# Ridgeline plots
ridgelineMetricPlots <- function(metric, dataset = cdres, print_plots = TRUE, hide_y_grid = TRUE) {


  sr <- subset(dataset, met == metric)

  # Clamp only for r2
  if (identical(metric, "r2")) {
    sr$value <- ifelse(sr$value < -1, -1, sr$value)
  }

  # ---- order facets (unchanged look) ----
  mvals_src <- sr |>
    dplyr::group_by(src) |>
    dplyr::summarize(m = mean(value, na.rm = TRUE), .groups = "drop") |>
    dplyr::arrange(m)
  sr$src <- factor(sr$src, levels = mvals_src$src)

  # common theme tweak to hide horizontal grid if desired
  grid_tweak <- if (hide_y_grid) ggplot2::theme(
    panel.grid.major.y = ggplot2::element_blank(),
    panel.grid.minor.y = ggplot2::element_blank()
  ) else ggplot2::theme()

  # by source dataset (remove ridge outlines with color = NA)
  p1 <- sr |>
    ggplot2::ggplot(ggplot2::aes(x = value, y = trg, fill = model)) +
    ggridges::geom_density_ridges(alpha = 0.5, color = NA) +
    ggplot2::facet_grid(src ~ .) +
    ggplot2::ggtitle(paste0(metric, " by source dataset")) +
    ggplot2::scale_fill_manual(values = modelcolors) +
    grid_tweak

  # reorder targets
  mvals_trg <- sr |>
    dplyr::group_by(trg) |>
    dplyr::summarize(m = mean(value, na.rm = TRUE), .groups = "drop") |>
    dplyr::arrange(m)
  sr$trg <- factor(sr$trg, levels = mvals_trg$trg)

  # by target dataset (remove ridge outlines with color = NA)
  p3 <- sr |>
    ggplot2::ggplot(ggplot2::aes(x = value, y = src, fill = model)) +
    ggridges::geom_density_ridges(alpha = 0.5, color = NA) +
    ggplot2::facet_grid(trg ~ .) +
    ggplot2::ggtitle(paste0(metric, " by target dataset")) +
    ggplot2::scale_fill_manual(values = modelcolors) +
    grid_tweak

  if (isTRUE(print_plots)) {
    print(p1)
    print(p3)
  }
  invisible(list(src = p1, trg = p3))
}


ridgelineMetricPlots(metric='r2')


```



# Load in the data
```{r}
if (!exists("models"))    models    <- c('deepttc','graphdrp','lgbm','xgboostdrp','uno')
if (!exists("exvivo"))    exvivo    <- c('mpnst','beataml','sarcoma','pancreatic','bladder','liver','novartis','colorectal')
if (!exists("cellline"))  cellline  <- c('nci60','ctrpv2','fimm','gcsi','gdscv1','gdscv2','prism','ccle')
if (!exists("datasetcolors")) {
  all_ds <- c(cellline, exvivo)
  datasetcolors <- setNames(colorRampPalette(RColorBrewer::brewer.pal(8,"Set3"))(length(all_ds)), all_ds)
}
if (!exists("modelcolors")) {
  modelcolors <- setNames(RColorBrewer::brewer.pal(n=6,"RdYlBu")[seq_along(models)], models)
}

# ---- load performance summaries (lightweight) -------------------------
cdres <- getModelPerformanceData()

# ---- helper: build per-example predictions  ---------------
# By default, keep it small: one model (UNO) across all available src!=trg
build_all_preds <- function(model_subset = "uno",
                            exclude_src = c("beataml","mpnst"),
                            targets_subset = c(cellline, exvivo),
                            require_cross = TRUE) {
  mdl_list <- if (identical(model_subset, "all")) models else model_subset

  purrr::map_dfr(mdl_list, function(m) {
    df <- getModelPredictionData(dset = m)
    if (is.null(df)) stop(sprintf("getModelPredictionData('%s') returned NULL", m))

    df |>
      dplyr::filter(
        !source %in% exclude_src,
        target %in% targets_subset,
        if (require_cross) source != target else TRUE
      ) |>
      dplyr::mutate(model = m)
  })
}


```


# Create a heatmap that shows how dataset performance (scc) with all target/source combos. 
# This example was just for uno / spearman. 
```{r}
transfer_matrix <- function(cdres, metric="scc", mdl="uno"){
  cdres |>
    # filter(met == metric, model == mdl, src != trg) |>
    filter(met == metric, model == mdl, src != trg) |>
    group_by(src, trg) |>
    summarise(mu = mean(value, na.rm = TRUE), n = dplyr::n(), .groups = "drop") |>
    tidyr::complete(src, trg, fill = list(mu = NA_real_, n = 0))
}

plot_transfer_heatmap <- function(mat_df, title, limits = c(-.2,.6)) {
  ggplot(mat_df, aes(x = trg, y = src, fill = mu)) +
    geom_tile(color = "white") +
    scale_fill_distiller(palette = "RdBu", limits = limits, direction = 1, na.value = "grey95") +
    geom_point(aes(size = n), shape = 21, stroke = .2, alpha = .9, fill = NA) +
    coord_fixed() + theme_bw(base_size = 11) +
    labs(title = title, x = "Target dataset", y = "Source dataset", fill = "Perf", size = "#pairs") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

mat_uno_scc <- transfer_matrix(cdres, metric="scc", mdl="uno")
plot_transfer_heatmap(mat_uno_scc, title = "Cross-dataset transfer (UNO, Spearman)")
ggsave("fig_transfer_matrix_uno_scc.pdf", width = 7, height = 5)


```

#Drug consistency plot - performance vs variability
# we could add colors to this - blue for cell line, red for ex vivo 

```{r}
# Starting off with uno
preds_cons <- build_all_preds(model_subset = "uno")

drug_consistency_tbl <- preds_cons |>
  group_by(improve_chem_id, source, target) |>
  summarise(r2_cell = if (n() >= 3) cor(auc_pred, auc_true, method="pearson")^2 else NA_real_,
            .groups="drop") |>
  group_by(improve_chem_id) |>
  summarise(
    mean_r2 = mean(r2_cell, na.rm=TRUE),
    sd_r2   = sd(r2_cell, na.rm=TRUE),
    n_cells = sum(!is.na(r2_cell)),
    .groups = "drop"
  ) |>
  filter(is.finite(mean_r2), is.finite(sd_r2), n_cells >= 3)

gg <- ggplot(drug_consistency_tbl,
       aes(x = mean_r2, y = sd_r2)) +
  geom_hline(yintercept = median(drug_consistency_tbl$sd_r2, na.rm=TRUE), linetype="dotted") +
  geom_vline(xintercept = median(drug_consistency_tbl$mean_r2, na.rm=TRUE), linetype="dotted") +
  geom_point(alpha=.8) +
  theme_bw(base_size=11) +
  labs(
    title = "Drug Consistency: mean performance vs variability across all datasets (UNO)",
    x = "mean R²",
    y = expression(SD~of~R^2)
  )


if (requireNamespace("ggrepel", quietly = TRUE)) {
  # Optionally label top/bottom 10 by mean/SD
  top_lab <- drug_consistency_tbl |>
    slice_max(mean_r2, n = 10) |>
    bind_rows(slice_max(drug_consistency_tbl, sd_r2, n = 10))
  gg <- gg + ggrepel::geom_text_repel(
    data = top_lab,
    aes(label = improve_chem_id),
    size = 3, max.overlaps = 40
  )
}

print(gg)
ggsave("fig_drug_consistency_uno.pdf", width=6.5, height=4.5)
  
```








# Cross dataset performance vs fraction of drugs in the source datset. I have two versions of this, the first one is just red / blue for ex vivo vs cell line.

```{r}

nz_list <- function(x) {
  if (is.null(x) || length(x) == 0 || all(is.na(x))) character() else x
}

# Infer measured drug panels from rows where each dataset is the TARGET
infer_panels_from_predictions <- function(panel_model = "uno") {
  df <- getModelPredictionData(dset = panel_model) |>
    select(source, target, improve_chem_id, auc_true) |>
    collect()

  trg_panel <- df |>
    filter(is.finite(auc_true)) |>
    group_by(target) |>
    summarise(drugs_trg = list(unique(improve_chem_id)), .groups = "drop")

  src_panel <- trg_panel |>
    rename(source = target, drugs_src = drugs_trg)

  list(src = src_panel, trg = trg_panel)
}

# Build perf vs. overlap for every model in cdres
perf_vs_overlap_all_models <- function(cdres, metric = "scc",
                                      sets, exvivo_vec = exvivo,
                                      models_subset = NULL) {
  if (is.null(models_subset)) models_subset <- sort(unique(cdres$model))

  purrr::map_dfr(models_subset, function(mdl) {
    mat <- cdres |>
      # filter(met == metric, model == mdl, src != trg) |>
      filter(met == metric, model == mdl) |>
      group_by(src, trg) |>
      summarise(mu = mean(value, na.rm = TRUE),
                n  = dplyr::n(), .groups = "drop") |>
      left_join(sets$src, by = c("src" = "source")) |>
      left_join(sets$trg, by = c("trg" = "target")) |>
      mutate(
        target_coverage = purrr::map2_dbl(drugs_src, drugs_trg, ~ {
          xs <- nz_list(.x); ys <- nz_list(.y)
          if (length(ys) == 0) return(NA_real_)
          length(intersect(xs, ys)) / length(ys)
        }),
        target_domain = if_else(trg %in% exvivo_vec, "ex vivo", "cell line"),
        model = mdl
      )
    mat
  })
}

# --- run once to get panels, then build & plot for ALL MODELS ----------
sets   <- infer_panels_from_predictions(panel_model = "uno")  # any model is fine
pvo_all <- perf_vs_overlap_all_models(cdres, metric = "scc", sets = sets)



# Faceted plot (all models), thinner lines, no size legend
ggplot(pvo_all, aes(target_coverage, mu, color = target_domain)) +
  geom_point(size = 2, alpha = 0.85,
             position = position_jitter(width = 0.01, height = 0)) +
  stat_smooth(aes(weight = n, color = target_domain),
              method = "lm", se = TRUE, linewidth = 0.6) +
  scale_color_manual(values = c("cell line" = "#377eb8",
                                "ex vivo"   = "#e41a1c")) +
  theme_bw(base_size = 11) +
  labs(title = "Transfer vs Fraction of Target Drugs in Source (All models, Spearman)",
       x = "Fraction of target drug panel present in source",
       y = "Mean cross-dataset performance") +
  facet_wrap(~ model, ncol = 3)




```

#The second version of 'Cross dataset performance vs fraction of drugs in the source datset' - more granular information.
```{r}
# split
pvo_cell <- dplyr::filter(pvo_all, target_domain == "cell line")
pvo_ex   <- dplyr::filter(pvo_all, target_domain == "ex vivo")

# distinct palettes per row (overlap across rows is OK)
pal_cell <- setNames(scales::hue_pal(l = 55, c = 100)(length(unique(pvo_cell$trg))),
                     sort(unique(pvo_cell$trg)))
pal_ex   <- setNames(scales::hue_pal(l = 65, c = 90 )(length(unique(pvo_ex$trg))),
                     sort(unique(pvo_ex$trg)))

# common y-range for both rows
ylims <- c(-0.3, 0.65)
ybrks <- seq(-0.25, 0.6, by = 0.25)

p_top <- ggplot(pvo_cell, aes(target_coverage, mu, color = trg)) +
  geom_point(size = 2, alpha = 0.9,
             position = position_jitter(width = 0.01, height = 0)) +
  stat_smooth(aes(weight = n), method = "lm", se = TRUE,
              linewidth = 0.5, color = "black") +
  scale_color_manual(values = pal_cell, name = "Cell-line targets", drop = FALSE) +
  scale_x_continuous(limits = c(0, 1), breaks = NULL) +
  scale_y_continuous(limits = ylims, breaks = ybrks) +
  theme_bw(base_size = 11) +
  theme(
    legend.position = "right",
    axis.title.x = element_blank(),
    axis.text.x  = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  labs(y = "Mean cross-dataset performance") +
  facet_wrap(~ model, ncol = 5)

p_bot <- ggplot(pvo_ex, aes(target_coverage, mu, color = trg)) +
  geom_point(size = 2, alpha = 0.9,
             position = position_jitter(width = 0.01, height = 0)) +
  stat_smooth(aes(weight = n), method = "lm", se = TRUE,
              linewidth = 0.5, color = "black") +
  scale_color_manual(values = pal_ex, name = "Ex vivo targets", drop = FALSE) +
  scale_x_continuous(limits = c(0, 1), breaks = c(0, 0.5, 1), labels = c("0","0.5","1")) +
  scale_y_continuous(limits = ylims, breaks = ybrks) +
  theme_bw(base_size = 11) +
  theme(legend.position = "right") +
  labs(
    x = "Fraction of target drug panel present in source",
    y = NULL
  ) +
  facet_wrap(~ model, ncol = 5)

(p_top / p_bot) +
  plot_annotation(
    title = "Performance based on Drugs in Source"
  ) &
  theme(plot.title = element_text(hjust = 0.5))


```

# Model pair comparisions. p value is model 1 vs 2.

```{r}

paired_grid_all_pretty <- function(cdres, metric = "scc",
                                   model_order = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
                                   breaks = c(-0.25, 0, 0.25, 0.5, 0.75),
                                   ncol = 5) {
  # --- helpers ---
  safe_palette_for_targets <- function(trg_vec) {
    lvls <- sort(unique(trg_vec))
    stopifnot(length(lvls) > 0)
    if (exists("datasetcolors")) {
      base <- datasetcolors[names(datasetcolors) %in% lvls]
      missing <- setdiff(lvls, names(base))
      if (length(missing) > 0) {
        add <- setNames(scales::hue_pal()(length(missing)), missing)
        base <- c(base, add)
      }
      base[lvls]
    } else {
      setNames(scales::hue_pal()(length(lvls)), lvls)
    }
  }
  pval_fmt <- function(p) ifelse(is.na(p), "p=NA",
                           ifelse(p < 1e-3, "p<0.001", sprintf("p=%.3g", p)))

  have_models <- intersect(model_order, unique(cdres$model))
  if (length(have_models) < 2) stop("Need at least two models present in cdres.")

  # 1) cell means per (model, src, trg)
  cell_means <- cdres %>%
    dplyr::filter(met == metric, src != trg, model %in% have_models) %>%
    dplyr::group_by(model, src, trg) %>%
    dplyr::summarise(mu = mean(value, na.rm = TRUE), .groups = "drop") %>%
    tidyr::pivot_wider(names_from = model, values_from = mu)

  # 2) long table for every unordered model pair
  pairs <- t(combn(have_models, 2))
  long_list <- apply(pairs, 1, function(pr) {
    a <- pr[1]; b <- pr[2]
    if (!all(c(a, b) %in% names(cell_means))) return(NULL)
    cell_means %>%
      dplyr::select(src, trg, !!rlang::sym(a), !!rlang::sym(b)) %>%
      tidyr::drop_na(!!rlang::sym(a), !!rlang::sym(b)) %>%
      dplyr::transmute(src, trg, x = .data[[a]], y = .data[[b]],
                       pair = paste0(a, " vs ", b), a = a, b = b)
  })
  long_list <- long_list[!vapply(long_list, is.null, logical(1))]
  if (!length(long_list)) stop("No overlapping (src→trg) cells across model pairs.")
  long <- dplyr::bind_rows(long_list)

  # 3) stats per pair: winner by HL median (y − x), keep p for evidence
  stats <- long %>%
    dplyr::group_by(pair) %>%
    dplyr::summarise(
      a = dplyr::first(a),
      b = dplyr::first(b),
      wt = list(tryCatch(
        stats::wilcox.test(y, x, paired = TRUE, exact = FALSE,
                           conf.int = TRUE, conf.level = 0.95),
        error = function(e) NULL
      )),
      p  = ifelse(is.null(wt[[1]]), NA_real_, wt[[1]]$p.value),
      HL = ifelse(is.null(wt[[1]]), NA_real_, unname(wt[[1]]$estimate)),
      .groups = "drop"
    ) %>%
    dplyr::mutate(
      winner = dplyr::case_when(
        is.na(HL)            ~ "NA",
        HL >  0              ~ b,   # y-axis model wins
        HL <  0              ~ a,   # x-axis model wins
        TRUE                 ~ "tie"
      ),
      label = paste0(pair, "\n", winner, ", ", pval_fmt(p))
    )
  lab_map <- setNames(stats$label, stats$pair)

  # 4) palette only for targets that appear
  pal <- safe_palette_for_targets(long$trg)

  # 5) common square limits + nice breaks
  rng <- range(c(long$x, long$y), na.rm = TRUE)
  if (!is.finite(diff(rng)) || diff(rng) == 0) rng <- rng + c(-0.5, 0.5)
  pad <- diff(rng) * 0.05
  lims <- c(rng[1] - pad, rng[2] + pad)
  brx  <- breaks[breaks >= lims[1] & breaks <= lims[2]]
  if (!length(brx)) brx <- scales::pretty_breaks(5)(lims)

  ggplot(long, aes(x = x, y = y, color = trg)) +
    geom_abline(slope = 1, intercept = 0, linetype = "dashed",
                linewidth = 0.5, color = "grey55") +
    geom_point(alpha = 0.9, size = 0.7) +
    scale_color_manual(values = pal, name = "Target dataset", drop = FALSE) +
    coord_equal(xlim = lims, ylim = lims, expand = FALSE) +
    scale_x_continuous(breaks = brx) +
    scale_y_continuous(breaks = brx) +
    theme_bw(base_size = 11) +
    theme(
      panel.grid.minor = element_blank(),
      panel.grid.major = element_line(colour = "grey88"),
      axis.text  = element_text(size = 8),
      axis.title = element_text(size = 10),
      legend.position   = "right",
      legend.title      = element_text(size = 10),
      legend.text       = element_text(size = 9),
      legend.key.size   = unit(0.35, "cm"),
      legend.spacing.y  = unit(0.2, "cm"),
      strip.text = element_text(size = 7, face = "bold",  # smaller facet titles
                                margin = margin(2, 2, 2, 2)),
      panel.spacing = unit(0.5, "lines"),
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold")
    ) +
    labs(
      title = paste0("Paired Comparisons across model pairs"),
      x = "Model 1 (average spearman correlation)", y = "Model 2 (average spearman correlation)"
    ) +
    facet_wrap(~ pair, labeller = labeller(pair = lab_map), ncol = ncol)
}

# --- Use it ---
pg_plot <- paired_grid_all_pretty(
  cdres, metric = "scc",
  model_order = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
  ncol = 5
)

pg_plot
# ggsave("fig_paired_all_models_scc_winner.pdf", pg_plot, width = 14, height = 7.5, dpi = 300)

```

# This was another way to compare between models, but is honestly kind of confusing and may not be worth keeping.
```{r}
# Symmetric triangular heatmap using MEAN differences (ROW − COLUMN):
# - Upper triangle  (row < col):  cell line   Δmean = mean( row − column )
# - Lower triangle  (row > col):  ex vivo     Δmean = mean( row − column )
# - Diagonal        (row = col):  within-model Δmean = mean(ex vivo) − mean(cell line)
paired_heatmap_triangular_mean <- function(cdres,
                                           metric = "scc",
                                           model_order = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
                                           limits = c(-0.15, 0.15),
                                           show_labels = TRUE) {

  have_models <- intersect(model_order, unique(cdres$model))
  stopifnot(length(have_models) >= 2)

  dom_of_trg <- function(trg) ifelse(trg %in% exvivo, "ex vivo", "cell line")

  # Per-(model, src, trg) average performance + domain tag
  cell_means <- cdres %>%
    dplyr::filter(met == metric, src != trg, model %in% have_models) %>%
    dplyr::group_by(model, src, trg) %>%
    dplyr::summarise(mu = mean(value, na.rm = TRUE), .groups = "drop") %>%
    dplyr::mutate(domain = dom_of_trg(trg))

  # --- Pairwise (between models) MEAN Δ and paired t-test, per domain -----------
  # IMPORTANT CHANGE: d <- x - y (row − column), and t.test(x, y, paired=TRUE)
  compute_pairwise_domain_mean <- function(df_domain) {
    wide <- tidyr::pivot_wider(df_domain, names_from = model, values_from = mu)
    prs  <- t(combn(have_models, 2))
    rows <- apply(prs, 1, function(pr) {
      a <- pr[1]; b <- pr[2]  # 'a' will be the row model; 'b' the column model if (row=a, col=b)
      sub <- wide %>% dplyr::select(src, trg, !!rlang::sym(a), !!rlang::sym(b)) %>% tidyr::drop_na()
      if (nrow(sub) < 3) return(NULL)
      x <- sub[[a]]; y <- sub[[b]]
      d  <- x - y                              # <-- row − column
      md <- mean(d, na.rm = TRUE)
      tt <- tryCatch(stats::t.test(x, y, paired = TRUE), error = function(e) NULL)
      tibble::tibble(a = a, b = b,
                     MEAN_D = md,
                     p      = if (!is.null(tt)) tt$p.value else NA_real_,
                     n      = sum(stats::complete.cases(d)))
    })
    rows <- rows[!vapply(rows, is.null, logical(1))]
    if (!length(rows)) return(NULL)
    dplyr::bind_rows(rows)
  }

  by_dom <- cell_means %>%
    dplyr::group_by(domain) %>%
    tidyr::nest() %>%
    dplyr::mutate(res = purrr::map(data, compute_pairwise_domain_mean)) %>%
    tidyr::unnest(res) %>%
    dplyr::select(domain, a, b, MEAN_D, p, n)

  # --- Diagonal (within-model) MEAN gap: mean(ex vivo) − mean(cell line) --------
  diag_tbl <- purrr::map_dfr(have_models, function(m) {
    xe <- cell_means %>% dplyr::filter(model == m, domain == "ex vivo")   %>% dplyr::pull(mu)
    yc <- cell_means %>% dplyr::filter(model == m, domain == "cell line") %>% dplyr::pull(mu)
    if (length(xe) < 3 || length(yc) < 3) {
      tibble::tibble(model = m, MEAN_diag = NA_real_, p_diag = NA_real_)
    } else {
      md <- mean(xe, na.rm = TRUE) - mean(yc, na.rm = TRUE)
      tt <- tryCatch(stats::t.test(xe, yc, paired = FALSE), error = function(e) NULL) # Welch
      tibble::tibble(model = m, MEAN_diag = md,
                     p_diag = if (!is.null(tt)) tt$p.value else NA_real_)
    }
  })

  # Grid of cells
  grid <- expand.grid(row_model = have_models, col_model = have_models, stringsAsFactors = FALSE)
  grid$row_model <- factor(grid$row_model, levels = have_models)
  grid$col_model <- factor(grid$col_model, levels = have_models)
  grid$i <- as.integer(grid$row_model); grid$j <- as.integer(grid$col_model)

  # Lookup now returns Δmean = (ROW − COLUMN) for requested domain
  lookup_mean <- function(dom, row, col) {
    m1 <- by_dom %>% dplyr::filter(domain == dom, a == row, b == col)
    if (nrow(m1) == 1) return(c(MD = m1$MEAN_D, p = m1$p, found = TRUE))      # already row−col
    m2 <- by_dom %>% dplyr::filter(domain == dom, a == col, b == row)
    if (nrow(m2) == 1) return(c(MD = -m2$MEAN_D, p = m2$p, found = TRUE))     # invert if stored reversed
    c(MD = NA_real_, p = NA_real_, found = FALSE)
  }

  vals <- purrr::pmap_dfr(list(grid$i, grid$j, as.character(grid$row_model), as.character(grid$col_model)),
                          function(i, j, rm, cm) {
                            if (i == j) {
                              d <- diag_tbl %>% dplyr::filter(model == rm)
                              tibble::tibble(row_model = rm, col_model = cm,
                                             MD = d$MEAN_diag, p = d$p_diag,
                                             domain_used = "ex vivo − cell line")
                            } else if (i < j) {
                              v <- lookup_mean("cell line", rm, cm)
                              tibble::tibble(row_model = rm, col_model = cm,
                                             MD = as.numeric(v["MD"]), p = as.numeric(v["p"]),
                                             domain_used = "cell line")
                            } else {
                              v <- lookup_mean("ex vivo", rm, cm)
                              tibble::tibble(row_model = rm, col_model = cm,
                                             MD = as.numeric(v["MD"]), p = as.numeric(v["p"]),
                                             domain_used = "ex vivo")
                            }
                          })

  star <- function(p) dplyr::case_when(
    is.na(p) ~ "",
    p < 1e-4 ~ "****",
    p < 1e-3 ~ "***",
    p < 1e-2 ~ "**",
    p < 0.05 ~ "*",
    TRUE     ~ ""
  )
  vals$lab <- if (show_labels) sprintf("%.3f%s", vals$MD, star(vals$p)) else ""

  ggplot(vals, aes(x = col_model, y = row_model, fill = MD)) +
    geom_tile(color = "white", linewidth = 0.3) +
    {if (show_labels) geom_text(aes(label = lab), size = 3)} +
    scale_fill_distiller(palette = "RdBu", direction = 1,
                         limits = limits, oob = scales::squish,
                         name = "Mean Difference\n(row − column)") +
    coord_fixed() +
    theme_bw(11) +
    theme(
      axis.title = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid = element_blank(),
      legend.position = "right"
    ) +
    labs(
      title = "Average Model Differences",
      subtitle = "upper = cell line, lower = ex vivo; diagonal = ex vivo − cell line")
}

# Example
p_tri_mean <- paired_heatmap_triangular_mean(cdres, metric = "scc",
                                             model_order = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
                                             limits = c(-0.15, 0.15))
p_tri_mean
# ggsave("fig_pair_heatmap_triangular_mean_scc.pdf", p_tri_mean, width = 6.8, height = 6.2, dpi = 300)



```

#This does the same as above, but for all datasets. Again its confusing and probably should not make the final cut. Keeping for inspiration, maybe some variation would be better.
```{r}

paired_heatmap_triangular_mean_by_target_4x4 <- function(
  cdres,
  metric = "scc",
  model_order = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
  limits = c(-0.15, 0.15),
  show_labels = TRUE,
  diag_mode = c("na","zero")
) {
  diag_mode <- match.arg(diag_mode)
  have_models <- intersect(model_order, unique(cdres$model))
  stopifnot(length(have_models) >= 2)

  dom_of_trg <- function(trg) ifelse(trg %in% exvivo, "ex vivo", "cell line")

  # Per-(model, src, trg) mean + domain
  cell_means <- cdres %>%
    dplyr::filter(met == metric, src != trg, model %in% have_models) %>%
    dplyr::group_by(model, src, trg) %>%
    dplyr::summarise(mu = mean(value, na.rm = TRUE), .groups = "drop") %>%
    dplyr::mutate(trg_domain = dom_of_trg(trg))

  # ---- Per-target average (for annotation) ----
  # avg over models and sources for that target
  avg_by_trg <- cell_means %>%
    dplyr::group_by(trg, trg_domain) %>%
    dplyr::summarise(avg_mu = mean(mu, na.rm = TRUE), .groups = "drop")

  # Helper to compute pairwise Δ mean per target (fill only domain-matching triangle)
  compute_for_target <- function(df_trg) {
    trgnm <- df_trg$trg[1]; dom <- df_trg$trg_domain[1]
    wide <- tidyr::pivot_wider(df_trg, names_from = model, values_from = mu)
    prs  <- t(combn(have_models, 2))

    rows <- apply(prs, 1, function(pr) {
      a <- pr[1]; b <- pr[2]
      sub <- wide %>% dplyr::select(src, !!rlang::sym(a), !!rlang::sym(b)) %>% tidyr::drop_na()
      if (nrow(sub) < 3) return(NULL)
      x <- sub[[a]]; y <- sub[[b]]
      d  <- y - x
      md <- mean(d, na.rm = TRUE)
      tt <- tryCatch(stats::t.test(y, x, paired = TRUE), error = function(e) NULL)
      tibble::tibble(trg = trgnm, trg_domain = dom,
                     a = a, b = b, MD = md,
                     p = if (!is.null(tt)) tt$p.value else NA_real_,
                     n = sum(stats::complete.cases(d)))
    })
    rows <- rows[!vapply(rows, is.null, logical(1))]
    if (!length(rows)) return(NULL)
    out <- dplyr::bind_rows(rows)

    # Tile grid for this target
    grid <- expand.grid(row_model = have_models, col_model = have_models, stringsAsFactors = FALSE)
    grid$row_model <- factor(grid$row_model, levels = have_models)
    grid$col_model <- factor(grid$col_model, levels = have_models)
    grid$i <- as.integer(grid$row_model); grid$j <- as.integer(grid$col_model)

    # Δ mean = (Column − Row), using either (a=row,b=col) or flipped
    get_md <- function(row, col) {
      m1 <- out %>% dplyr::filter(a == row, b == col)
      if (nrow(m1) == 1) return(c(MD = -m1$MD, p = m1$p))   # flip sign
      m2 <- out %>% dplyr::filter(a == col, b == row)
      if (nrow(m2) == 1) return(c(MD = m2$MD, p = m2$p))    # flip sign
      c(MD = NA_real_, p = NA_real_)
    }

    purrr::pmap_dfr(
      list(grid$i, grid$j, as.character(grid$row_model), as.character(grid$col_model)),
      function(i, j, rm, cm) {
        if (i == j) {
          if (diag_mode == "zero") {
            tibble::tibble(trg = trgnm, trg_domain = dom,
                           row_model = rm, col_model = cm,
                           MD = 0, p = NA_real_, which_tri = "diag")
          } else {
            tibble::tibble(trg = trgnm, trg_domain = dom,
                           row_model = rm, col_model = cm,
                           MD = NA_real_, p = NA_real_, which_tri = "diag")
          }
        } else if (i < j && dom == "cell line") {
          mdp <- get_md(rm, cm)
          tibble::tibble(trg = trgnm, trg_domain = dom,
                         row_model = rm, col_model = cm,
                         MD = as.numeric(mdp["MD"]), p = as.numeric(mdp["p"]),
                         which_tri = "upper_cellline")
        } else if (i > j && dom == "ex vivo") {
          mdp <- get_md(rm, cm)
          tibble::tibble(trg = trgnm, trg_domain = dom,
                         row_model = rm, col_model = cm,
                         MD = as.numeric(mdp["MD"]), p = as.numeric(mdp["p"]),
                         which_tri = "lower_exvivo")
        } else {
          tibble::tibble(trg = trgnm, trg_domain = dom,
                         row_model = rm, col_model = cm,
                         MD = NA_real_, p = NA_real_, which_tri = "offdomain")
        }
      }
    )
  }

  mats <- cell_means %>%
    dplyr::group_by(trg) %>%
    tidyr::nest() %>%
    dplyr::mutate(res = purrr::map(data, compute_for_target)) %>%
    tidyr::unnest(res) %>%
    dplyr::mutate(
      row_model = factor(row_model, levels = have_models),
      col_model = factor(col_model, levels = have_models)
    )

  # Drop NA tiles → blanks for off-domain cells
  mats_plot <- mats %>% dplyr::filter(is.finite(MD))

  # Facet order: cell-line first, then ex vivo
  if (exists("cellline") && exists("exvivo")) {
    facet_levels <- c(cellline, exvivo)
  } else {
    trg_domains <- mats %>% dplyr::distinct(trg, trg_domain)
    facet_levels <- c(
      trg_domains %>% dplyr::filter(trg_domain == "cell line") %>% dplyr::arrange(trg) %>% dplyr::pull(trg),
      trg_domains %>% dplyr::filter(trg_domain == "ex vivo")   %>% dplyr::arrange(trg) %>% dplyr::pull(trg)
    )
  }
  mats_plot$trg <- factor(mats_plot$trg, levels = facet_levels)
  avg_by_trg$trg <- factor(avg_by_trg$trg, levels = facet_levels)

  # Build corner-annotation data:
  #  - cell line: top-left -> (x=first model, y=first model)
  #  - ex vivo:   bottom-right -> (x=last model,  y=last model)
# Build corner-annotation data (fix y positions):
#  - cell line: top-left  -> x = first model, y = LAST model
#  - ex vivo:   bottom-right -> x = last model,  y = FIRST model
  first_m <- have_models[1]
  last_m  <- tail(have_models, 1)
  
  ann_cell <- avg_by_trg %>%
    dplyr::filter(trg_domain == "cell line") %>%
    dplyr::transmute(
      trg,
      x = factor(first_m, levels = have_models),   # left
      y = factor(last_m,  levels = have_models),   # top
      lab = sprintf("Avg=%.3f", avg_mu),
      hjust = 0, vjust = 1.1
    )
  
  ann_ex <- avg_by_trg %>%
    dplyr::filter(trg_domain == "ex vivo") %>%
    dplyr::transmute(
      trg,
      x = factor(last_m,  levels = have_models),   # right
      y = factor(first_m, levels = have_models),   # bottom
      lab = sprintf("Avg=%.3f", avg_mu),
      hjust = 1, vjust = -0.1
    )


  # Labels inside tiles
  star <- function(p) dplyr::case_when(
    is.na(p) ~ "",
    p < 1e-4 ~ "****",
    p < 1e-3 ~ "***",
    p < 1e-2 ~ "**",
    p < 0.05 ~ "*",
    TRUE     ~ ""
  )
  mats_plot$lab <- if (show_labels) sprintf("%.3f%s", mats_plot$MD, star(mats_plot$p)) else ""

  ggplot(mats_plot, aes(x = col_model, y = row_model, fill = MD)) +
    # Tile grid
    geom_tile(color = "white", linewidth = 0.25, width = 0.999, height = 0.999) +
    {if (show_labels) geom_text(aes(label = lab), size = 2.0)} +
    # Corner annotations (do not inherit tile aesthetics)
    geom_text(data = ann_cell, aes(x = x, y = y, label = lab, hjust = hjust, vjust = vjust),
              inherit.aes = FALSE, size = 3, fontface = "bold") +
    geom_text(data = ann_ex,   aes(x = x, y = y, label = lab, hjust = hjust, vjust = vjust),
              inherit.aes = FALSE, size = 3, fontface = "bold") +
    scale_fill_distiller(
      palette = "RdBu", direction = 1,
      limits = limits, oob = scales::squish,
      name = "Mean Difference (row − col)") +
    coord_fixed() +
    theme_bw(base_size = 9) +
    theme(
      axis.title = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1, size = 7),
      axis.text.y = element_text(size = 7),
      strip.text = element_text(face = "bold", size = 9, margin = margin(2,2,2,2)),
      panel.grid = element_blank(),
      panel.spacing = grid::unit(0.15, "lines"),
      plot.margin = margin(4,4,4,4),
      legend.position = "right",
      legend.title = element_text(size = 8),
      legend.text  = element_text(size = 7),
      legend.key.size = grid::unit(0.28, "cm"),
      legend.spacing.y = grid::unit(0.12, "cm")
    ) +
    guides(
      fill = guide_colorbar(
        title.position = "top",
        label.position = "right",
        barheight = grid::unit(3.0, "cm"),
        barwidth  = grid::unit(0.26, "cm")
      )
    ) +
    labs(
      title = paste0("Model pair differences per target"),
    ) +
    facet_wrap(~ trg, ncol = 4, nrow = 4)
}

# Example
p_4x4 <- paired_heatmap_triangular_mean_by_target_4x4(
  cdres, metric = "scc",
  model_order = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
  limits = c(-0.15, 0.15),
  diag_mode = "na",
  show_labels = TRUE
)
p_4x4

ggsave("fig_pair_heatmap_triangular_mean_by_target_scc_4x4_avgannot.pdf",
       p_4x4, width = 8, height = 8, dpi = 300)

```


# I think we should have this in the paper (atleast in supp). It's simple, but it represents the results(ish) that the original algorithm papers claim to have. They do perform well when trained/tested within the same datasets. The problem comes when we compare between datasets - but this one is helpful for setting up the problem.

```{r}
# Per-dataset Self scores heatmap
model_self_scores_heatmap <- function(
  cdres,
  metric = "scc",
  model_order = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
  datasets_cellline = if (exists("cellline")) cellline else NULL,
  datasets_exvivo   = if (exists("exvivo"))   exvivo   else NULL,
  show_labels = TRUE,
  limits = NULL,
  palette = "RdBu"
) {
  have_models <- intersect(model_order, unique(cdres$model))

  self_tbl <- cdres %>%
    filter(met == metric, src == trg, model %in% have_models) %>%
    group_by(model, trg) %>%
    summarise(mu = mean(value, na.rm=TRUE), .groups="drop")

  # Order: cell lines, ex vivo
  col_order <- c(datasets_cellline, datasets_exvivo)
  self_tbl$model <- factor(self_tbl$model, levels = rev(have_models))
  self_tbl$trg   <- factor(self_tbl$trg,   levels = col_order)

  if (is.null(limits)) {
    rng <- range(self_tbl$mu, na.rm=TRUE); pad <- diff(rng)*0.05
    limits <- c(rng[1]-pad, rng[2]+pad)
  }
  self_tbl$lab <- if (show_labels) sprintf("%.3f", self_tbl$mu) else ""

  ggplot(self_tbl, aes(x=trg, y=model, fill=mu)) +
    geom_tile(width=0.999, height=0.999, color="white", linewidth=0.25) +
    {if(show_labels) geom_text(aes(label=lab), size=3)} +
    scale_fill_distiller(palette=palette, direction=1,
                         limits=c(.65,.9), oob=scales::squish,
                         name="Spearman" )+
    coord_fixed() +
    theme_bw(11) +
    theme(axis.title=element_blank(),
          axis.text.x=element_text(angle=45,hjust=1),
          panel.grid=element_blank(),
          plot.title=element_text(hjust=0.5)) +
    labs(
      title="Performance within Datasets, Spearman",
      subtitle=""
    )
}

# Example
p <- model_self_scores_heatmap(
  cdres, metric = "scc",
  model_order = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
  limits = NULL,
  show_labels = TRUE,
)
p
# ggsave("fig_model_by_dataset_self_heatmap_scc_avgs_grouped.pdf", p, width = 12, height = 5.5, dpi = 300)

```

# Here is where the problem is... When the models are tested across datasets, performance drops significantly (on average).
# But this also shows that a few of the datasets inherently perform better. 
# This also shows that lgbm performs the best between datasets (on average) - particularly across model types.

```{r}
# Main heatmap with aggregated Self scores
model_by_dataset_heatmap <- function(
  cdres,
  metric = "scc",
  model_order = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
  datasets_cellline = if (exists("cellline")) cellline else NULL,
  datasets_exvivo   = if (exists("exvivo"))   exvivo   else NULL,
  show_labels = TRUE,
  limits = NULL,
  palette = "RdBu",
  sep_lines = TRUE
) {
  stopifnot(all(c("model","met","src","trg","value") %in% names(cdres)))

  have_models <- intersect(model_order, unique(cdres$model))

  # Cross-prediction means (exclude self)
  base <- cdres %>%
    dplyr::filter(met == metric, src != trg, model %in% have_models) %>%
    dplyr::group_by(model, trg) %>%
    dplyr::summarise(mu = mean(value, na.rm = TRUE), .groups = "drop")

  # Self scores (src==trg)
  self_tbl <- cdres %>%
    dplyr::filter(met == metric, src == trg, model %in% have_models) %>%
    dplyr::group_by(model, trg) %>%
    dplyr::summarise(mu = mean(value, na.rm = TRUE), .groups = "drop")

  # Aggregated Self (cell line/ex vivo)
  self_cell <- self_tbl %>% filter(trg %in% datasets_cellline) %>%
    group_by(model) %>% summarise(trg = "Self (cell line)", mu = mean(mu, na.rm=TRUE), .groups="drop")
  self_ex   <- self_tbl %>% filter(trg %in% datasets_exvivo) %>%
    group_by(model) %>% summarise(trg = "Self (ex vivo)", mu = mean(mu, na.rm=TRUE), .groups="drop")

  # Aggregated averages (cross only)
  avg_cell <- base %>% filter(trg %in% datasets_cellline) %>%
    group_by(model) %>% summarise(trg = "Avg (cell line)", mu = mean(mu, na.rm=TRUE), .groups="drop")
  avg_ex <- base %>% filter(trg %in% datasets_exvivo) %>%
    group_by(model) %>% summarise(trg = "Avg (ex vivo)", mu = mean(mu, na.rm=TRUE), .groups="drop")
  avg_all <- base %>% filter(trg %in% c(datasets_cellline, datasets_exvivo)) %>%
    group_by(model) %>% summarise(trg = "Avg (overall)", mu = mean(mu, na.rm=TRUE), .groups="drop")

  # Column order
  col_order <- c(datasets_cellline, "Self (cell line)", "Avg (cell line)",
                 datasets_exvivo,   "Self (ex vivo)",  "Avg (ex vivo)",
                 "Avg (overall)")

  # Assemble long table
  long_tbl <- bind_rows(
    base %>% filter(trg %in% c(datasets_cellline, datasets_exvivo)),
    self_cell, self_ex, avg_cell, avg_ex, avg_all
  )
  long_tbl$model <- factor(long_tbl$model, levels = rev(have_models))
  long_tbl$trg   <- factor(long_tbl$trg, levels = col_order)

  # Color limits
  if (is.null(limits)) {
    rng <- range(long_tbl$mu, na.rm=TRUE); pad <- diff(rng)*0.05
    limits <- c(rng[1]-pad, rng[2]+pad)
  }
  long_tbl$lab <- if (show_labels) sprintf("%.3f", long_tbl$mu) else ""

  # Vertical separators
  vlines <- tibble::tibble(x = c(
    length(datasets_cellline) + 0.5,
    length(datasets_cellline) + 1 + 0.5,
    length(datasets_cellline) + 2 + length(datasets_exvivo) + 0.5,
    length(datasets_cellline) + 3 + length(datasets_exvivo) + 0.5
  ))

  ggplot(long_tbl, aes(x = trg, y = model, fill = mu)) +
    geom_tile(width=0.999, height=0.999, color="white", linewidth=0.25) +
    {if(show_labels) geom_text(aes(label=lab), size=3)} +
    scale_fill_distiller(palette=palette, direction=1,
                         limits=limits, oob=scales::squish,
                         name=paste0("Mean ", metric)) +
    {if(sep_lines) geom_vline(data=vlines, aes(xintercept=x), inherit.aes=FALSE,
                              color="grey30", linewidth=0.5)} +
    coord_fixed() +
    theme_bw(11) +
    theme(axis.title=element_blank(),
          axis.text.x=element_text(angle=45,hjust=1),
          panel.grid=element_blank(),
          plot.title=element_text(hjust=0.5)) +
    labs(
      title=paste0("Average performance by Model")
    )
}

# Example
p_mod_ds <- model_by_dataset_heatmap(
  cdres, metric = "scc",
  model_order = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
  limits = NULL,
  show_labels = TRUE,
  sep_lines = TRUE
)
p_mod_ds
ggsave("fig_model_by_dataset_mean_heatmap_scc_avgs_grouped.pdf", p_mod_ds, width = 12, height = 5.5, dpi = 300)


```


# These 3d heat maps are another, more granular, way to diplay results of models across datasets / model types. 

```{r}
#### 3D solid-tile heatmap for cell lines

metric        <- "scc"
models_keep   <- c("deepttc","graphdrp","lgbm","xgboostdrp")
tile_opacity  <- 0.7   # 0..1

# Source order (global Y), drop novartis AND drop ccle from SOURCE list
global_src_order <- if (exists("cellline") && exists("exvivo")) {
  setdiff(c(cellline, exvivo), c("novartis", "ccle"))
} else NULL

# Targets: cell line only, drop novartis (CCLE remains as a valid TARGET)
trg_order <- if (exists("cellline")) setdiff(cellline, "novartis") else NULL

# Aggregate means per (model, src, trg), restrict to cell-line targets
mu_tbl <- cdres %>%
  filter(
    met == metric,
    src != trg,
    !src %in% c("novartis", "ccle"),   # <-- DROP CCLE from source here
    !trg %in% c("novartis"),           # keep CCLE as target
    model %in% models_keep,
    if (exists("cellline")) trg %in% cellline else TRUE
  ) %>%
  group_by(model, src, trg) %>%
  summarise(mu = mean(value, na.rm = TRUE), .groups = "drop")

models_present <- intersect(models_keep, unique(mu_tbl$model))
if (is.null(global_src_order)) global_src_order <- sort(unique(mu_tbl$src))
global_src_order <- intersect(global_src_order, unique(mu_tbl$src))
if (is.null(trg_order)) trg_order <- sort(unique(mu_tbl$trg))

# ---- Fixed shared color scale for BOTH figures ----
cmin <- 0; cmid <- 0.5; cmax <- 1
# Divergent 3-stop: red (0), neutral gray (0.5), blue (1)
colorscale_rnb <- list(
  list(0.00, "rgb(178,24,43)"),
  list(0.50, "rgb(221,221,221)"),
  list(1.00, "rgb(33,102,172)")
)
clamp01 <- function(v) pmax(cmin, pmin(cmax, v))

# Start plot with transparent surface only to show ONE shared colorbar
plt <- plot_ly() %>%
  add_surface(
    x = c(0,1), y = c(0,1), z = matrix(as.numeric(NA), 2, 2),
    surfacecolor = matrix(c(cmin, cmax, cmin, cmax), 2, 2),
    colorscale = colorscale_rnb, cmin = cmin, cmax = cmax,
    opacity = 0, showscale = TRUE,
    colorbar = list(title = paste0("Mean"))
  )

# Helper: add one solid tile as a tiny 2×2 surface spanning [x0,x1]×[y0,y1] at z=zlev
add_tile_surface <- function(p, x0, x1, y0, y1, zlev, value, opacity) {
  vclamp <- clamp01(value)
  add_surface(
    p,
    x = c(x0, x1), y = c(y0, y1), z = matrix(as.numeric(zlev), 2, 2),
    surfacecolor = matrix(vclamp, 2, 2),
    colorscale = colorscale_rnb, cmin = cmin, cmax = cmax,
    showscale = FALSE,
    opacity = opacity,
    lighting = list(ambient = 1, diffuse = 0, specular = 0),
    contours = list(
      x = list(show = TRUE, start = x0, end = x1, size = x1 - x0,
               color = "rgba(255,255,255,1)", width = 2),
      y = list(show = TRUE, start = y0, end = y1, size = y1 - y0,
               color = "rgba(255,255,255,1)", width = 2)
    ),
    hovertemplate = paste(
      "Source: %{customdata[0]}<br>",
      "Target: %{customdata[1]}<br>",
      "Mean ", metric, ": %{surfacecolor:.3f}<extra></extra>"
    ),
    customdata = array(list(c(NA), c(NA)), dim = c(2, 2, 2))
  )
}

# Build tiles per model (layer = model index on Z)
for (m in models_present) {
  src_present <- mu_tbl %>% filter(model == m) %>% pull(src) %>% unique() %>%
    intersect(global_src_order)
  if (!length(src_present)) next

  # centers -> edges for full-size outer tiles
  x_centers <- seq_along(trg_order); x_edges <- c(x_centers - 0.5, tail(x_centers,1) + 0.5)
  y_rows <- match(src_present, global_src_order); y_edges <- c(y_rows - 0.5, tail(y_rows,1) + 0.5)
  zlev <- which(models_present == m)

  grid_df <- mu_tbl %>%
    filter(model == m) %>%
    complete(src = src_present, trg = trg_order) %>%
    arrange(match(src, src_present), match(trg, trg_order))

  nY <- length(src_present); nX <- length(trg_order)
  if (nY == 0 || nX == 0) next

  for (iy in seq_len(nY)) for (ix in seq_len(nX)) {
    val <- grid_df$mu[(iy - 1) * nX + ix]
    if (is.na(val)) next
    x0 <- x_edges[ix]; x1 <- x_edges[ix+1]
    y0 <- y_edges[iy]; y1 <- y_edges[iy+1]

    plt <- add_tile_surface(plt, x0, x1, y0, y1, zlev, val, tile_opacity)

    # invisible marker with full hover text
    plt <- plt %>% add_trace(
      type = "scatter3d", mode = "markers",
      x = mean(c(x0,x1)), y = mean(c(y0,y1)), z = as.numeric(zlev),
      marker = list(size = 0.1, color = "rgba(0,0,0,0)"),
      showlegend = FALSE,
      hovertemplate = paste0(
        "Model: ", m, "<br>",
        "Source: ", src_present[iy], "<br>",
        "Target: ", trg_order[ix], "<br>",
        "Mean ", metric, ": ", sprintf("%.3f", clamp01(val)), "<extra></extra>"
      )
    )
  }
}

# ---- TOP Y spacer ----
y_max <- length(global_src_order)
x_min <- 0.5; x_max <- length(trg_order) + 0.5
y_sp_lo <- y_max + 0.51; y_sp_hi <- y_max + 0.99  # thin band above the top row
plt <- plt %>% add_surface(
  x = c(x_min, x_max), y = c(y_sp_lo, y_sp_hi), z = matrix(1, 2, 2),
  surfacecolor = matrix(c(cmin, cmin, cmin, cmin), 2, 2),
  colorscale = colorscale_rnb, cmin = cmin, cmax = cmax,
  showscale = FALSE, opacity = 0, hoverinfo = "skip"
)

plt %>%
  layout(
    title = paste0("Cell Line Model Performance"),
    scene = list(
      xaxis = list(title = "Target",
                   tickmode = "array",
                   tickvals = seq_along(trg_order), ticktext = trg_order,
                   autorange = FALSE, range = c(0.5, length(trg_order) + 0.5)),
      yaxis = list(title = "Source",
                   tickmode = "array",
                   tickvals = seq_along(global_src_order), ticktext = global_src_order,
                   autorange = FALSE, range = c(0.5, y_max)),  # extra top row
      zaxis = list(title = "Model",
                   tickmode = "array",
                   tickvals = seq_along(models_present), ticktext = models_present),
      aspectmode = "cube"
    )
  )


```

```{r}
#### 3D solid-tile heatmap for ex vivo targets
library(dplyr)
library(tidyr)
library(plotly)

metric        <- "scc"
models_keep   <- c("deepttc","graphdrp","lgbm","xgboostdrp")
tile_opacity  <- 0.7   # 0..1

global_src_order <- if (exists("cellline") && exists("exvivo")) {
  setdiff(c(cellline, exvivo), c("novartis", "ccle"))
} else NULL

# Targets: EX VIVO only, drop novartis (bc its not included.)
trg_order <- if (exists("exvivo")) setdiff(exvivo, "novartis") else NULL

# Aggregate means per (model, src, trg), restrict to EX VIVO targets
mu_tbl <- cdres %>%
  filter(
    met == metric,
    src != trg,
    !src %in% c("novartis", "ccle"),
    !trg %in% c("novartis"),
    model %in% models_keep,
    if (exists("exvivo")) trg %in% exvivo else TRUE
  ) %>%
  group_by(model, src, trg) %>%
  summarise(mu = mean(value, na.rm = TRUE), .groups = "drop")

models_present <- intersect(models_keep, unique(mu_tbl$model))
if (is.null(global_src_order)) global_src_order <- sort(unique(mu_tbl$src))
global_src_order <- intersect(global_src_order, unique(mu_tbl$src))
if (is.null(trg_order)) trg_order <- sort(unique(mu_tbl$trg))

cmin <- 0; cmid <- 0.5; cmax <- 1
colorscale_rnb <- list(
  list(0.00, "rgb(178,24,43)"),   # red (low)
  list(0.50, "rgb(221,221,221)"), # neutral gray (mid)
  list(1.00, "rgb(33,102,172)")   # blue (high)
)
clamp01 <- function(v) pmax(cmin, pmin(cmax, v))

plt <- plot_ly() %>%
  add_surface(
    x = c(0,1), y = c(0,1), z = matrix(as.numeric(NA), 2, 2),
    surfacecolor = matrix(c(cmin, cmax, cmin, cmax), 2, 2),
    colorscale = colorscale_rnb, cmin = cmin, cmax = cmax,
    opacity = 0, showscale = TRUE,
    colorbar = list(title = paste0("Mean"))
  )

# Helper: add one solid tile as a tiny 2×2 surface spanning [x0,x1]×[y0,y1] at z=zlev
add_tile_surface <- function(p, x0, x1, y0, y1, zlev, value, opacity) {
  vclamp <- clamp01(value)
  add_surface(
    p,
    x = c(x0, x1), y = c(y0, y1), z = matrix(as.numeric(zlev), 2, 2),
    surfacecolor = matrix(vclamp, 2, 2),
    colorscale = colorscale_rnb, cmin = cmin, cmax = cmax,
    showscale = FALSE,
    opacity = opacity,
    lighting = list(ambient = 1, diffuse = 0, specular = 0),
    contours = list(
      x = list(show = TRUE, start = x0, end = x1, size = x1 - x0,
               color = "rgba(255,255,255,1)", width = 2),
      y = list(show = TRUE, start = y0, end = y1, size = y1 - y0,
               color = "rgba(255,255,255,1)", width = 2)
    ),
    hovertemplate = paste(
      "Source: %{customdata[0]}<br>",
      "Target: %{customdata[1]}<br>",
      "Mean ", metric, ": %{surfacecolor:.3f}<extra></extra>"
    ),
    customdata = array(list(c(NA), c(NA)), dim = c(2, 2, 2))
  )
}

# Build tiles per model (layer = model index on Z)
for (m in models_present) {
  src_present <- mu_tbl %>% filter(model == m) %>% pull(src) %>% unique() %>%
    intersect(global_src_order)
  if (!length(src_present)) next

  # centers -> edges (full-size outer tiles)
  x_centers <- seq_along(trg_order); x_edges <- c(x_centers - 0.5, tail(x_centers,1) + 0.5)
  y_rows <- match(src_present, global_src_order); y_edges <- c(y_rows - 0.5, tail(y_rows,1) + 0.5)
  zlev <- which(models_present == m)

  grid_df <- mu_tbl %>%
    filter(model == m) %>%
    complete(src = src_present, trg = trg_order) %>%
    arrange(match(src, src_present), match(trg, trg_order))

  nY <- length(src_present); nX <- length(trg_order)
  if (nY == 0 || nX == 0) next

  for (iy in seq_len(nY)) for (ix in seq_len(nX)) {
    val <- grid_df$mu[(iy - 1) * nX + ix]
    if (is.na(val)) next
    x0 <- x_edges[ix]; x1 <- x_edges[ix+1]
    y0 <- y_edges[iy]; y1 <- y_edges[iy+1]

    plt <- add_tile_surface(plt, x0, x1, y0, y1, zlev, val, tile_opacity)

    # invisible marker with full hover text
    plt <- plt %>% add_trace(
      type = "scatter3d", mode = "markers",
      x = mean(c(x0,x1)), y = mean(c(y0,y1)), z = as.numeric(zlev),
      marker = list(size = 0.1, color = "rgba(0,0,0,0)"),
      showlegend = FALSE,
      hovertemplate = paste0(
        "Model: ", m, "<br>",
        "Source: ", src_present[iy], "<br>",
        "Target: ", trg_order[ix], "<br>",
        "Mean ", metric, ": ", sprintf("%.3f", clamp01(val)), "<extra></extra>"
      )
    )
  }
}

# ---- Add a single transparent TOP layer as spacer (no label, no legend) ----
z_spacer <- length(models_present) + 1
plt <- plt %>%
  add_surface(
    x = c(0.5, length(trg_order) + 0.5),
    y = c(0.5, length(global_src_order) + 0.5),
    z = matrix(as.numeric(z_spacer), 2, 2),
    surfacecolor = matrix(c(cmid, cmid, cmid, cmid), 2, 2),  # irrelevant; fully transparent
    colorscale = colorscale_rnb, cmin = cmin, cmax = cmax,
    showscale = FALSE, opacity = 0,
    name = NULL, showlegend = FALSE, hoverinfo = "skip"
  )

plt %>%
  layout(
    title = paste0("Ex Vivo Model Performance"),
    scene = list(
      xaxis = list(title = "Target",
                   tickmode = "array",
                   tickvals = seq_along(trg_order), ticktext = trg_order,
                   autorange = FALSE, range = c(0.5, length(trg_order) + 0.5)),
      yaxis = list(title = "Source",
                   tickmode = "array",
                   tickvals = seq_along(global_src_order), ticktext = global_src_order,
                   autorange = FALSE, range = c(0.5, length(global_src_order) + 0.5)),
      zaxis = list(title = "Model",
                   tickmode = "array",
                   tickvals = seq_along(models_present),  # spacer has no tick/label
                   ticktext = models_present),
      aspectmode = "cube"
    )
  )


```


#drug setup
```{r}
# Detect common column names for drug id / truth / prediction
.standardize_pred_cols <- function(df) {
  drug_col <- intersect(names(df), c("improve_chem_id","improve_drug_id","drug_id","chem_id"))[1]
  y_col    <- intersect(names(df), c("y_true","auc_true","true","label"))[1]
  yhat_col <- intersect(names(df), c("y_pred","auc_pred","pred","score","score_pred"))[1]
  need <- c("source","target", drug_col, y_col, yhat_col, "model")
  if (!all(need %in% names(df))) {
    stop(sprintf(
      "Missing columns. Needed (some auto-detected): %s\nFound: %s",
      paste(need, collapse=", "), paste(names(df), collapse=", ")
    ), call. = FALSE)
  }
  dplyr::rename(df,
    drug = !!drug_col,
    y    = !!y_col,
    yhat = !!yhat_col
  )
}

# Build per-drug cross-dataset performance from predictions
# method = "spearman" (scc) or "pearson"
drug_transfer_scores <- function(models = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
                                 exclude_src = c("beataml","mpnst"),
                                 targets_subset = c(cellline, exvivo),
                                 method = "spearman",
                                 min_n = 8) {
  stopifnot(method %in% c("spearman","pearson"))
  purrr::map_dfr(models, function(m) {
    df <- getModelPredictionData(dset = m) |>
      dplyr::mutate(model = m) |>
      dplyr::filter(!source %in% exclude_src,
                    target %in% targets_subset,
                    source != target)
    df <- .standardize_pred_cols(df)

    # per (src, trg, model, drug) correlation
    df %>%
      dplyr::group_by(source, target, model, drug) %>%
      dplyr::summarise(
        n = dplyr::n(),
        perf = suppressWarnings(stats::cor(y, yhat, method = method, use = "pairwise.complete.obs")),
        .groups = "drop"
      ) %>%
      dplyr::filter(is.finite(perf), n >= min_n)
  })
}

```


# Best and worst drugs for cross-dataset transfer.
# In this case they end all being between cell lines, but if ex vivo was in there, there would be more horiz bars.
```{r}


plot_drug_leaderboard <- function(method = "spearman",
                                  top_k = 20,
                                  models = c("deepttc","graphdrp","lgbm","xgboostdrp","uno")) {
  d <- drug_transfer_scores(models = models, method = method)

  d2 <- d %>%
    dplyr::mutate(domain = ifelse(target %in% get0("exvivo", ifnotfound = character()),
                                  "ex vivo", "cell line")) %>%
    dplyr::group_by(drug, domain) %>%
    dplyr::summarise(mu = mean(perf, na.rm = TRUE),
                     se = stats::sd(perf, na.rm = TRUE) / sqrt(pmax(1, dplyr::n())),
                     n  = dplyr::n(),
                     .groups = "drop")

  # choose globally by mean across domains
  keep <- d2 %>%
    dplyr::group_by(drug) %>%
    dplyr::summarise(gmu = mean(mu, na.rm = TRUE), .groups = "drop") %>%
    dplyr::arrange(dplyr::desc(gmu))
  top <- head(keep$drug, top_k)
  bot <- tail(keep$drug, top_k)
  d3  <- d2 %>% dplyr::filter(drug %in% c(top, bot)) %>%
    dplyr::mutate(drug = factor(drug, levels = unique(c(rev(top), bot))))

  p <- ggplot(d3, aes(x = mu, y = drug, color = domain)) +
    geom_point(size = 2) +
    geom_errorbarh(aes(xmin = mu - 1.96*se, xmax = mu + 1.96*se), height = 0) +
    scale_color_manual(values = c("cell line" = "#377eb8", "ex vivo" = "#e41a1c")) +
    theme_bw(11) +
    labs(title = "Drug transfer leaderboard (top & bottom)",
         subtitle = paste0("Method: ", method, " (mean ± 95% CI across models & sources)"),
         x = "Cross-dataset performance", y = NULL, color = "Target domain")
  print(p)
  invisible(p)
}

# Example
plot_drug_leaderboard(method = "spearman", top_k = 20)


```



# Larger scale version of earlier drug consistency plot
```{r}
plot_drug_consistency <- function(method = "spearman",
                                  stat_y = c("IQR","SD"),
                                  label_top = 10,
                                  models = c("deepttc","graphdrp","lgbm","xgboostdrp","uno")) {
  stat_y <- match.arg(stat_y)

  d <- drug_transfer_scores(models = models, method = method)

  agg <- d %>%
    dplyr::group_by(drug) %>%
    dplyr::summarise(
      mu  = mean(perf, na.rm = TRUE),
      sd  = stats::sd(perf, na.rm = TRUE),
      iqr = stats::IQR(perf, na.rm = TRUE),
      n   = dplyr::n(),
      .groups = "drop"
    )
  agg$varstat <- if (stat_y == "IQR") agg$iqr else agg$sd

  # Label a few most interesting (highest mu and lowest varstat)
  labset <- dplyr::bind_rows(
    agg %>% dplyr::arrange(desc(mu)) %>% head(label_top),
    agg %>% dplyr::arrange(varstat)   %>% head(label_top)
  ) %>% dplyr::distinct(drug)

  p <- ggplot(agg, aes(x = mu, y = varstat)) +
    geom_point(alpha = 0.8) +
    ggrepel::geom_text_repel(data = dplyr::semi_join(agg, labset, by = "drug"),
                             aes(label = drug), size = 3, max.overlaps = 100) +
    theme_bw(11) +
    labs(title = "Drug transfer: mean vs variability across datasets/models",
         subtitle = paste0("Method: ", method, "; variability = ", stat_y),
         x = "Mean cross-dataset performance",
         y = paste0(stat_y, " of cross-dataset performance"))
  print(p)
  invisible(p)
}

# Example
plot_drug_consistency(method = "spearman", stat_y = "IQR", label_top = 12)

```

