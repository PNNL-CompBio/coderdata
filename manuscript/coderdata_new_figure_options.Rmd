---
title: "morefigs"
author: "JJ"
date: "2025-08-25"
output: html_document
---

This document suggests specific figures to include in the coderdata manuscript.

# Data and scripting functions


Below is the setup for the figures. There are multiple dependencies as we 
explore different packages.

To avoid the reticulate mess, set it to FALSE and it will load with synapser.

```{r setup, include=FALSE}
use_reticulate = FALSE

source('coderdataFigureFunctions.R')
source('coderdataResultsFunctions.R')
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

# I am setting the default to reticulate (use_reticulate = TRUE). 
# If reticulate doesn't work for you, try arrow. 
# However, be warned that my arrow doesn't work so I haven't been able to test everything with it.


# Check your R arch via sessionInfo()
# if it is x86_64 (Platform: x86_64-apple-darwin23.6.0)
# Build reticulate environment with these commands, otherwise build normally.
# arch -x86_64 /usr/bin/python3 -m venv ~/.virtualenvs/r-reticulate-x86_64
# arch -x86_64 ~/.virtualenvs/r-reticulate-x86_64/bin/pip install -U pip
# arch -x86_64 ~/.virtualenvs/r-reticulate-x86_64/bin/pip install "numpy==2.1.*" "pandas>=2.2,<2.3" pyarrow fastparquet


# Ensure this RETICULATE_PYTHON path is correct.
if (use_reticulate) {
  Sys.setenv(RETICULATE_PYTHON="~/.virtualenvs/r-reticulate-x86_64/bin/python")
  library(reticulate)
} else {
  library(arrow)
}

library(synapser)
library(tidyverse)
library(rlang)




suppressWarnings(suppressMessages({
  if (!requireNamespace("ggrepel", quietly = TRUE)) install.packages("ggrepel")
  if (!requireNamespace("patchwork", quietly = TRUE)) install.packages("patchwork")
}))

```

# Setup the Data

First we have to downlaod the results of the model analysis from synpase and
set the color scheme for the rest of the manuscript. 


```{r}

models <- c('deepttc','graphdrp','lgbm','xgboostdrp','uno')
modelcolors <- RColorBrewer::brewer.pal(n=6,name='RdYlBu')
names(modelcolors) <- models


exvivo = c('mpnst','beataml','sarcoma','pancreatic','bladder',
           'liver','novartis','colorectal')
cellline = c('nci60','ctrpv2','fimm','gcsi','gdscv1','gdscv2','prism','ccle')

#cell line colors
ccols = RColorBrewer::brewer.pal(n = length(cellline),name = 'RdBu')
names(ccols) <- cellline

#ex vivo colors
ecols = RColorBrewer::brewer.pal(n = length(exvivo),name = 'PRGn')
names(ecols) <- exvivo

datasetcolors <- c(ccols,ecols)

# Either set info in ~/.synapseConfig, or use the `email` and `authToken` arguments of synLogin
synapser::synLogin()


```

# Load in the data

The results for the anlaysis are currently stored in parquet files on Synapse.
this leverages the code in the accompanying R scripts.

```{r get data, echo=FALSE}
if (!exists("models"))    models    <- c('deepttc','graphdrp','lgbm','xgboostdrp','uno')
if (!exists("exvivo"))    exvivo    <- c('mpnst','beataml','sarcoma','pancreatic','bladder','liver','novartis','colorectal')
if (!exists("cellline"))  cellline  <- c('nci60','ctrpv2','fimm','gcsi','gdscv1','gdscv2','prism','ccle')
if (!exists("datasetcolors")) {
  all_ds <- c(cellline, exvivo)
  datasetcolors <- setNames(colorRampPalette(RColorBrewer::brewer.pal(8,"Set3"))(length(all_ds)), all_ds)
}
if (!exists("modelcolors")) {
  modelcolors <- setNames(RColorBrewer::brewer.pal(n=6,"RdYlBu")[seq_along(models)], models)
}

# ---- load performance summaries (lightweight) -------------------------
cdres <- getModelPerformanceData()

# ---- helper: build per-example predictions  ---------------
# By default, keep it small: one model (UNO) across all available src!=trg
build_all_preds <- function(model_subset = "uno",
                            exclude_src = c("beataml","mpnst"),
                            targets_subset = c(cellline, exvivo),
                            require_cross = TRUE) {
  mdl_list <- if (identical(model_subset, "all")) models else model_subset

  purrr::map_dfr(mdl_list, function(m) {
    df <- getModelPredictionData(dset = m)
    if (is.null(df)) stop(sprintf("getModelPredictionData('%s') returned NULL", m))

    df |>
      dplyr::filter(
        !source %in% exclude_src,
        target %in% targets_subset,
        if (require_cross) source != target else TRUE
      ) |>
      dplyr::mutate(model = m)|>
      as.data.frame()
  })
}


```


# Model specific performancea cross source and target

First we evaluate how well the models perform across source and target datasets. 

A ridgeline plot will compare this in distribution.
```{r}

ridgelineMetricPlots(metric='r2')
```

We can also do a heatmap for each model type

```{r}

ev_res <- subset(cdres,trg%in%exvivo)
cl_res <- subset(cdres,trg%in%cellline)

transfer_matrix <- function(cdres, metric="scc", mdl="uno"){
  cdres |>
    # filter(met == metric, model == mdl, src != trg) |>
    filter(met == metric, model == mdl, src != trg) |>
    group_by(src, trg) |>
    summarise(mu = mean(value, na.rm = TRUE), n = dplyr::n(), .groups = "drop") |>
    tidyr::complete(src, trg, fill = list(mu = NA_real_, n = 0))
}


cl_res <- lapply(unique(cdres$model),function(mod){
  mat_uno_scc <- transfer_matrix(cl_res, metric="scc", mdl=mod)
  plot_transfer_heatmap(mat_uno_scc, title = paste0("Cross-dataset pred: ",mod))
  
})

ev_res <- lapply(unique(cdres$model),function(mod){
  mat_uno_scc <- transfer_matrix(ev_res, metric="scc", mdl=mod)
  plot_transfer_heatmap(mat_uno_scc, title = paste0("Cross-dataset pred: ",mod))
  
})

cowplot::plot_grid(plotlist=c(cl_res,ev_res),ncol=2)


ggsave("fig_transfer_matrix_scc.pdf", width = 7, height = 5)


```

This is a bit confusing, though probably better than the joy division plots
because it summarizes. 

# Variability across predictions

How do predictions vary? I'm not sure this is useful. Also runs out of memory
when run on all the models. 


```{r, eval = FALSE}

model_var <- lapply(unique(cdres$model),function (mod){
  
  # Starting off with uno
  preds_cons <- build_all_preds(model_subset = mod,targets_subset = cellline)

drug_consistency_tbl <- preds_cons |>
  group_by(improve_chem_id, source, target) |>
  summarise(r2_cell = if (n() >= 3) cor(auc_pred, auc_true, method="pearson")^2 else NA_real_,
            .groups="drop") |>
  group_by(improve_chem_id) |>
  summarise(
    mean_r2 = mean(r2_cell, na.rm=TRUE),
    sd_r2   = sd(r2_cell, na.rm=TRUE),
    n_cells = sum(!is.na(r2_cell)),
    .groups = "drop"
  ) |>
  filter(is.finite(mean_r2), is.finite(sd_r2), n_cells >= 3)

gg <- ggplot(drug_consistency_tbl,
       aes(x = mean_r2, y = sd_r2)) +
  geom_hline(yintercept = median(drug_consistency_tbl$sd_r2, na.rm=TRUE), linetype="dotted") +
  geom_vline(xintercept = median(drug_consistency_tbl$mean_r2, na.rm=TRUE), linetype="dotted") +
  geom_point(alpha=.8) +
  theme_bw(base_size=11) +
  labs(
    title = paste("Drug Consistency: mean performance vs variability across all datasets",mod),
    x = "mean R²",
    y = expression(SD~of~R^2)
  )


if (requireNamespace("ggrepel", quietly = TRUE)) {
  # Optionally label top/bottom 10 by mean/SD
  top_lab <- drug_consistency_tbl |>
    slice_max(mean_r2, n = 10) |>
    bind_rows(slice_max(drug_consistency_tbl, sd_r2, n = 10))
  gg <- gg + ggrepel::geom_text_repel(
    data = top_lab,
    aes(label = improve_chem_id),
    size = 3, max.overlaps = 40
  )
}
return(gg)
})

cowplot::plot_grid(plotlist=model_var)

ggsave("fig_drug_consistenc.pdf", width=6.5, height=4.5)
  
```



# Cross dataset performance vs fraction of drugs in the source datset. 
This plot asks how drug coverage alters dataset response.

I have two versions of this, the first one is just red / blue for ex vivo vs cell line.

```{r}

nz_list <- function(x) {
  if (is.null(x) || length(x) == 0 || all(is.na(x))) character() else x
}

# Infer measured drug panels from rows where each dataset is the TARGET
infer_panels_from_predictions <- function(panel_model = "deepttc") {
  df <- getModelPredictionData(dset = panel_model) |>
    select(source, target, improve_chem_id, auc_true) |>
    collect()

  trg_panel <- df |>
    filter(is.finite(auc_true)) |>
    group_by(target) |>
    summarise(drugs_trg = list(unique(improve_chem_id)), .groups = "drop")

  src_panel <- trg_panel |>
    rename(source = target, drugs_src = drugs_trg)

  list(src = src_panel, trg = trg_panel)
}

# Build perf vs. overlap for every model in cdres
perf_vs_overlap_all_models <- function(cdres, metric = "scc",
                                      sets, exvivo_vec = exvivo,
                                      models_subset = NULL) {
  if (is.null(models_subset)) models_subset <- sort(unique(cdres$model))

  purrr::map_dfr(models_subset, function(mdl) {
    mat <- cdres |>
      # filter(met == metric, model == mdl, src != trg) |>
      filter(met == metric, model == mdl) |>
      group_by(src, trg) |>
      summarise(mu = mean(value, na.rm = TRUE),
                n  = dplyr::n(), .groups = "drop") |>
      left_join(sets$src, by = c("src" = "source")) |>
      left_join(sets$trg, by = c("trg" = "target")) |>
      mutate(
        target_coverage = purrr::map2_dbl(drugs_src, drugs_trg, ~ {
          xs <- nz_list(.x); ys <- nz_list(.y)
          if (length(ys) == 0) return(NA_real_)
          length(intersect(xs, ys)) / length(ys)
        }),
        target_domain = if_else(trg %in% exvivo_vec, "ex vivo", "cell line"),
        model = mdl
      )
    mat
  })
}

# --- run once to get panels, then build & plot for ALL MODELS ----------
sets   <- infer_panels_from_predictions(panel_model = "deepttc")  # any model is fine - SG not sure cuz because uno was not universally run
pvo_all <- perf_vs_overlap_all_models(cdres, metric = "scc", sets = sets)



# Faceted plot (all models), thinner lines, no size legend
ggplot(pvo_all, aes(target_coverage, mu, color = target_domain)) +
  geom_point(size = 2, alpha = 0.85,
             position = position_jitter(width = 0.01, height = 0)) +
  stat_smooth(aes(weight = n, color = target_domain),
              method = "lm", se = TRUE, linewidth = 0.6) +
  scale_color_manual(values = c("cell line" = "#377eb8",
                                "ex vivo"   = "#e41a1c")) +
  theme_bw(base_size = 11) +
  labs(title = "Transfer vs Fraction of Target Drugs in Source (All models, Spearman)",
       x = "Fraction of target drug panel present in source",
       y = "Mean cross-dataset performance") +
  facet_wrap(~ model, ncol = 3)





```

#The second version of 'Cross dataset performance vs fraction of drugs in the source datset' - more granular information.


```{r}
# split
pvo_cell <- dplyr::filter(pvo_all, target_domain == "cell line")
pvo_ex   <- dplyr::filter(pvo_all, target_domain == "ex vivo")

# distinct palettes per row (overlap across rows is OK)
pal_cell <- setNames(scales::hue_pal(l = 55, c = 100)(length(unique(pvo_cell$trg))),
                     sort(unique(pvo_cell$trg)))
pal_ex   <- setNames(scales::hue_pal(l = 65, c = 90 )(length(unique(pvo_ex$trg))),
                     sort(unique(pvo_ex$trg)))

# common y-range for both rows
ylims <- c(-0.3, 0.65)
ybrks <- seq(-0.25, 0.6, by = 0.25)

p_top <- ggplot(pvo_cell, aes(target_coverage, mu, color = trg)) +
  geom_point(size = 2, alpha = 0.9,
             position = position_jitter(width = 0.01, height = 0)) +
  stat_smooth(aes(weight = n), method = "lm", se = TRUE,
              linewidth = 0.5, color = "black") +
  scale_color_manual(values = ccols, name = "Cell-line targets", drop = FALSE) +
  scale_x_continuous(limits = c(0, 1), breaks = NULL) +
  scale_y_continuous(limits = ylims, breaks = ybrks) +
  theme_bw(base_size = 11) +
  theme(
    legend.position = "right",
    axis.title.x = element_blank(),
    axis.text.x  = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  labs(y = "Mean cross-dataset performance") +
  facet_wrap(~ model, ncol = 5)

p_bot <- ggplot(pvo_ex, aes(target_coverage, mu, color = trg)) +
  geom_point(size = 2, alpha = 0.9,
             position = position_jitter(width = 0.01, height = 0)) +
  stat_smooth(aes(weight = n), method = "lm", se = TRUE,
              linewidth = 0.5, color = "black") +
  scale_color_manual(values = ecols, name = "Ex vivo targets", drop = FALSE) +
  scale_x_continuous(limits = c(0, 1), breaks = c(0, 0.5, 1), labels = c("0","0.5","1")) +
  scale_y_continuous(limits = ylims, breaks = ybrks) +
  theme_bw(base_size = 11) +
  theme(legend.position = "right") +
  labs(
    x = "Fraction of target drug panel present in source",
    y = NULL
  ) +
  facet_wrap(~ model, ncol = 5)

(p_top / p_bot) +
  plot_annotation(
    title = "Performance based on Drugs in Source"
  ) &
  theme(plot.title = element_text(hjust = 0.5))


```

# Model pair comparisions. p value is model 1 vs 2.

```{r}


# --- Use it ---
pg_plot <- paired_grid_all_pretty(
  cdres, metric = "scc",
  model_order = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
  ncol = 5
)

pg_plot
# ggsave("fig_paired_all_models_scc_winner.pdf", pg_plot, width = 14, height = 7.5, dpi = 300)

```

# This was another way to compare between models, but is honestly kind of confusing and may not be worth keeping.
```{r}

# Example
p_tri_mean <- paired_heatmap_triangular_mean(cdres, metric = "scc",
                                             model_order = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
                                             limits = c(-0.15, 0.15))
p_tri_mean
# ggsave("fig_pair_heatmap_triangular_mean_scc.pdf", p_tri_mean, width = 6.8, height = 6.2, dpi = 300)



```

#This does the same as above, but for all datasets. Again its confusing and probably should not make the final cut. Keeping for inspiration, maybe some variation would be better.
```{r}

# Example
p <- model_self_scores_heatmap(
  cdres, metric = "scc",
  model_order = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
  limits = NULL,
  show_labels = TRUE,
)
p
# ggsave("fig_model_by_dataset_self_heatmap_scc_avgs_grouped.pdf", p, width = 12, height = 5.5, dpi = 300)

```

# Here is where the problem is... When the models are tested across datasets, performance drops significantly (on average).
# But this also shows that a few of the datasets inherently perform better. 
# This also shows that lgbm performs the best between datasets (on average) - particularly across model types.

```{r}


# Example
p_mod_ds <- model_by_dataset_heatmap(
  cdres, metric = "scc",
  model_order = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
  limits = NULL,
  show_labels = TRUE,
  sep_lines = TRUE
)
p_mod_ds
ggsave("fig_model_by_dataset_mean_heatmap_scc_avgs_grouped.pdf", p_mod_ds, width = 12, height = 5.5, dpi = 300)


```


# These 3d heat maps are another, more granular, way to diplay results of models across datasets / model types. 

```{r 3d not gonna work, eval=FALSE}
#### 3D solid-tile heatmap for cell lines

metric        <- "scc"
models_keep   <- c("deepttc","graphdrp","lgbm","xgboostdrp")
tile_opacity  <- 0.7   # 0..1

# Source order (global Y), drop novartis AND drop ccle from SOURCE list
global_src_order <- if (exists("cellline") && exists("exvivo")) {
  setdiff(c(cellline, exvivo), c("novartis", "ccle"))
} else NULL

# Targets: cell line only, drop novartis (CCLE remains as a valid TARGET)
trg_order <- if (exists("cellline")) setdiff(cellline, "novartis") else NULL

# Aggregate means per (model, src, trg), restrict to cell-line targets
mu_tbl <- cdres %>%
  filter(
    met == metric,
    src != trg,
    !src %in% c("novartis", "ccle"),   # <-- DROP CCLE from source here
    !trg %in% c("novartis"),           # keep CCLE as target
    model %in% models_keep,
    if (exists("cellline")) trg %in% cellline else TRUE
  ) %>%
  group_by(model, src, trg) %>%
  summarise(mu = mean(value, na.rm = TRUE), .groups = "drop")

models_present <- intersect(models_keep, unique(mu_tbl$model))
if (is.null(global_src_order)) global_src_order <- sort(unique(mu_tbl$src))
global_src_order <- intersect(global_src_order, unique(mu_tbl$src))
if (is.null(trg_order)) trg_order <- sort(unique(mu_tbl$trg))

# ---- Fixed shared color scale for BOTH figures ----
cmin <- 0; cmid <- 0.5; cmax <- 1
# Divergent 3-stop: red (0), neutral gray (0.5), blue (1)
colorscale_rnb <- list(
  list(0.00, "rgb(178,24,43)"),
  list(0.50, "rgb(221,221,221)"),
  list(1.00, "rgb(33,102,172)")
)
clamp01 <- function(v) pmax(cmin, pmin(cmax, v))

# Start plot with transparent surface only to show ONE shared colorbar
plt <- plot_ly() %>%
  add_surface(
    x = c(0,1), y = c(0,1), z = matrix(as.numeric(NA), 2, 2),
    surfacecolor = matrix(c(cmin, cmax, cmin, cmax), 2, 2),
    colorscale = colorscale_rnb, cmin = cmin, cmax = cmax,
    opacity = 0, showscale = TRUE,
    colorbar = list(title = paste0("Mean"))
  )

# Helper: add one solid tile as a tiny 2×2 surface spanning [x0,x1]×[y0,y1] at z=zlev
add_tile_surface <- function(p, x0, x1, y0, y1, zlev, value, opacity) {
  vclamp <- clamp01(value)
  add_surface(
    p,
    x = c(x0, x1), y = c(y0, y1), z = matrix(as.numeric(zlev), 2, 2),
    surfacecolor = matrix(vclamp, 2, 2),
    colorscale = colorscale_rnb, cmin = cmin, cmax = cmax,
    showscale = FALSE,
    opacity = opacity,
    lighting = list(ambient = 1, diffuse = 0, specular = 0),
    contours = list(
      x = list(show = TRUE, start = x0, end = x1, size = x1 - x0,
               color = "rgba(255,255,255,1)", width = 2),
      y = list(show = TRUE, start = y0, end = y1, size = y1 - y0,
               color = "rgba(255,255,255,1)", width = 2)
    ),
    hovertemplate = paste(
      "Source: %{customdata[0]}<br>",
      "Target: %{customdata[1]}<br>",
      "Mean ", metric, ": %{surfacecolor:.3f}<extra></extra>"
    ),
    customdata = array(list(c(NA), c(NA)), dim = c(2, 2, 2))
  )
}

# Build tiles per model (layer = model index on Z)
for (m in models_present) {
  src_present <- mu_tbl %>% filter(model == m) %>% pull(src) %>% unique() %>%
    intersect(global_src_order)
  if (!length(src_present)) next

  # centers -> edges for full-size outer tiles
  x_centers <- seq_along(trg_order); x_edges <- c(x_centers - 0.5, tail(x_centers,1) + 0.5)
  y_rows <- match(src_present, global_src_order); y_edges <- c(y_rows - 0.5, tail(y_rows,1) + 0.5)
  zlev <- which(models_present == m)

  grid_df <- mu_tbl %>%
    filter(model == m) %>%
    complete(src = src_present, trg = trg_order) %>%
    arrange(match(src, src_present), match(trg, trg_order))

  nY <- length(src_present); nX <- length(trg_order)
  if (nY == 0 || nX == 0) next

  for (iy in seq_len(nY)) for (ix in seq_len(nX)) {
    val <- grid_df$mu[(iy - 1) * nX + ix]
    if (is.na(val)) next
    x0 <- x_edges[ix]; x1 <- x_edges[ix+1]
    y0 <- y_edges[iy]; y1 <- y_edges[iy+1]

    plt <- add_tile_surface(plt, x0, x1, y0, y1, zlev, val, tile_opacity)

    # invisible marker with full hover text
    plt <- plt %>% add_trace(
      type = "scatter3d", mode = "markers",
      x = mean(c(x0,x1)), y = mean(c(y0,y1)), z = as.numeric(zlev),
      marker = list(size = 0.1, color = "rgba(0,0,0,0)"),
      showlegend = FALSE,
      hovertemplate = paste0(
        "Model: ", m, "<br>",
        "Source: ", src_present[iy], "<br>",
        "Target: ", trg_order[ix], "<br>",
        "Mean ", metric, ": ", sprintf("%.3f", clamp01(val)), "<extra></extra>"
      )
    )
  }
}

# ---- TOP Y spacer ----
y_max <- length(global_src_order)
x_min <- 0.5; x_max <- length(trg_order) + 0.5
y_sp_lo <- y_max + 0.51; y_sp_hi <- y_max + 0.99  # thin band above the top row
plt <- plt %>% add_surface(
  x = c(x_min, x_max), y = c(y_sp_lo, y_sp_hi), z = matrix(1, 2, 2),
  surfacecolor = matrix(c(cmin, cmin, cmin, cmin), 2, 2),
  colorscale = colorscale_rnb, cmin = cmin, cmax = cmax,
  showscale = FALSE, opacity = 0, hoverinfo = "skip"
)

plt %>%
  layout(
    title = paste0("Cell Line Model Performance"),
    scene = list(
      xaxis = list(title = "Target",
                   tickmode = "array",
                   tickvals = seq_along(trg_order), ticktext = trg_order,
                   autorange = FALSE, range = c(0.5, length(trg_order) + 0.5)),
      yaxis = list(title = "Source",
                   tickmode = "array",
                   tickvals = seq_along(global_src_order), ticktext = global_src_order,
                   autorange = FALSE, range = c(0.5, y_max)),  # extra top row
      zaxis = list(title = "Model",
                   tickmode = "array",
                   tickvals = seq_along(models_present), ticktext = models_present),
      aspectmode = "cube"
    )
  )


```

Another 3d option i'm going to skip
```{r why do we need 3d?, eval=FALSE}
#### 3D solid-tile heatmap for ex vivo targets
library(dplyr)
library(tidyr)
library(plotly)

metric        <- "scc"
models_keep   <- c("deepttc","graphdrp","lgbm","xgboostdrp")
tile_opacity  <- 0.7   # 0..1

global_src_order <- if (exists("cellline") && exists("exvivo")) {
  setdiff(c(cellline, exvivo), c("novartis", "ccle"))
} else NULL

# Targets: EX VIVO only, drop novartis (bc its not included.)
trg_order <- if (exists("exvivo")) setdiff(exvivo, "novartis") else NULL

# Aggregate means per (model, src, trg), restrict to EX VIVO targets
mu_tbl <- cdres %>%
  filter(
    met == metric,
    src != trg,
    !src %in% c("novartis", "ccle"),
    !trg %in% c("novartis"),
    model %in% models_keep,
    if (exists("exvivo")) trg %in% exvivo else TRUE
  ) %>%
  group_by(model, src, trg) %>%
  summarise(mu = mean(value, na.rm = TRUE), .groups = "drop")

models_present <- intersect(models_keep, unique(mu_tbl$model))
if (is.null(global_src_order)) global_src_order <- sort(unique(mu_tbl$src))
global_src_order <- intersect(global_src_order, unique(mu_tbl$src))
if (is.null(trg_order)) trg_order <- sort(unique(mu_tbl$trg))

cmin <- 0; cmid <- 0.5; cmax <- 1
colorscale_rnb <- list(
  list(0.00, "rgb(178,24,43)"),   # red (low)
  list(0.50, "rgb(221,221,221)"), # neutral gray (mid)
  list(1.00, "rgb(33,102,172)")   # blue (high)
)
clamp01 <- function(v) pmax(cmin, pmin(cmax, v))

plt <- plot_ly() %>%
  add_surface(
    x = c(0,1), y = c(0,1), z = matrix(as.numeric(NA), 2, 2),
    surfacecolor = matrix(c(cmin, cmax, cmin, cmax), 2, 2),
    colorscale = colorscale_rnb, cmin = cmin, cmax = cmax,
    opacity = 0, showscale = TRUE,
    colorbar = list(title = paste0("Mean"))
  )

# Helper: add one solid tile as a tiny 2×2 surface spanning [x0,x1]×[y0,y1] at z=zlev
add_tile_surface <- function(p, x0, x1, y0, y1, zlev, value, opacity) {
  vclamp <- clamp01(value)
  add_surface(
    p,
    x = c(x0, x1), y = c(y0, y1), z = matrix(as.numeric(zlev), 2, 2),
    surfacecolor = matrix(vclamp, 2, 2),
    colorscale = colorscale_rnb, cmin = cmin, cmax = cmax,
    showscale = FALSE,
    opacity = opacity,
    lighting = list(ambient = 1, diffuse = 0, specular = 0),
    contours = list(
      x = list(show = TRUE, start = x0, end = x1, size = x1 - x0,
               color = "rgba(255,255,255,1)", width = 2),
      y = list(show = TRUE, start = y0, end = y1, size = y1 - y0,
               color = "rgba(255,255,255,1)", width = 2)
    ),
    hovertemplate = paste(
      "Source: %{customdata[0]}<br>",
      "Target: %{customdata[1]}<br>",
      "Mean ", metric, ": %{surfacecolor:.3f}<extra></extra>"
    ),
    customdata = array(list(c(NA), c(NA)), dim = c(2, 2, 2))
  )
}

# Build tiles per model (layer = model index on Z)
for (m in models_present) {
  src_present <- mu_tbl %>% filter(model == m) %>% pull(src) %>% unique() %>%
    intersect(global_src_order)
  if (!length(src_present)) next

  # centers -> edges (full-size outer tiles)
  x_centers <- seq_along(trg_order); x_edges <- c(x_centers - 0.5, tail(x_centers,1) + 0.5)
  y_rows <- match(src_present, global_src_order); y_edges <- c(y_rows - 0.5, tail(y_rows,1) + 0.5)
  zlev <- which(models_present == m)

  grid_df <- mu_tbl %>%
    filter(model == m) %>%
    complete(src = src_present, trg = trg_order) %>%
    arrange(match(src, src_present), match(trg, trg_order))

  nY <- length(src_present); nX <- length(trg_order)
  if (nY == 0 || nX == 0) next

  for (iy in seq_len(nY)) for (ix in seq_len(nX)) {
    val <- grid_df$mu[(iy - 1) * nX + ix]
    if (is.na(val)) next
    x0 <- x_edges[ix]; x1 <- x_edges[ix+1]
    y0 <- y_edges[iy]; y1 <- y_edges[iy+1]

    plt <- add_tile_surface(plt, x0, x1, y0, y1, zlev, val, tile_opacity)

    # invisible marker with full hover text
    plt <- plt %>% add_trace(
      type = "scatter3d", mode = "markers",
      x = mean(c(x0,x1)), y = mean(c(y0,y1)), z = as.numeric(zlev),
      marker = list(size = 0.1, color = "rgba(0,0,0,0)"),
      showlegend = FALSE,
      hovertemplate = paste0(
        "Model: ", m, "<br>",
        "Source: ", src_present[iy], "<br>",
        "Target: ", trg_order[ix], "<br>",
        "Mean ", metric, ": ", sprintf("%.3f", clamp01(val)), "<extra></extra>"
      )
    )
  }
}

# ---- Add a single transparent TOP layer as spacer (no label, no legend) ----
z_spacer <- length(models_present) + 1
plt <- plt %>%
  add_surface(
    x = c(0.5, length(trg_order) + 0.5),
    y = c(0.5, length(global_src_order) + 0.5),
    z = matrix(as.numeric(z_spacer), 2, 2),
    surfacecolor = matrix(c(cmid, cmid, cmid, cmid), 2, 2),  # irrelevant; fully transparent
    colorscale = colorscale_rnb, cmin = cmin, cmax = cmax,
    showscale = FALSE, opacity = 0,
    name = NULL, showlegend = FALSE, hoverinfo = "skip"
  )

plt %>%
  layout(
    title = paste0("Ex Vivo Model Performance"),
    scene = list(
      xaxis = list(title = "Target",
                   tickmode = "array",
                   tickvals = seq_along(trg_order), ticktext = trg_order,
                   autorange = FALSE, range = c(0.5, length(trg_order) + 0.5)),
      yaxis = list(title = "Source",
                   tickmode = "array",
                   tickvals = seq_along(global_src_order), ticktext = global_src_order,
                   autorange = FALSE, range = c(0.5, length(global_src_order) + 0.5)),
      zaxis = list(title = "Model",
                   tickmode = "array",
                   tickvals = seq_along(models_present),  # spacer has no tick/label
                   ticktext = models_present),
      aspectmode = "cube"
    )
  )


```



# I'm not sure if the arrow version will work for these final parts. My arrow is not working, so I can't test it.

#drug setup
```{r}
# Detect common column names for drug id / truth / prediction
.standardize_pred_cols <- function(df) {
  drug_col <- intersect(names(df), c("improve_chem_id","improve_drug_id","drug_id","chem_id"))[1]
  y_col    <- intersect(names(df), c("y_true","auc_true","true","label"))[1]
  yhat_col <- intersect(names(df), c("y_pred","auc_pred","pred","score","score_pred"))[1]
  need <- c("source","target", drug_col, y_col, yhat_col, "model")
  if (!all(need %in% names(df))) {
    stop(sprintf(
      "Missing columns. Needed (some auto-detected): %s\nFound: %s",
      paste(need, collapse=", "), paste(names(df), collapse=", ")
    ), call. = FALSE)
  }
  dplyr::rename(df,
    drug = !!drug_col,
    y    = !!y_col,
    yhat = !!yhat_col
  )
}


```


# Best and worst drugs for cross-dataset transfer.
# In this case they end all being between cell lines, but if ex vivo was in there, there would be more horiz bars.

```{r where did this go}


# Example
p_4x4 <- paired_heatmap_triangular_mean_by_target_4x4(
  cdres, metric = "scc",
  model_order = c("deepttc","graphdrp","lgbm","xgboostdrp","uno"),
  limits = c(-0.15, 0.15),
  diag_mode = "na",
  show_labels = TRUE
)
p_4x4

ggsave("fig_pair_heatmap_triangular_mean_by_target_scc_4x4_avgannot.pdf",
       p_4x4, width = 8, height = 8, dpi = 300)

```
#Very slow
I cannot get this to run. 

```{r, eval= FALSE}

# Example
plot_drug_leaderboard(method = "spearman", top_k = 20)


```



# Larger scale version of earlier drug consistency plot - also slow.
```{r}

p <- plot_drug_consistency(method="spearman", stat_y="IQR", label_top=12)
p


```

